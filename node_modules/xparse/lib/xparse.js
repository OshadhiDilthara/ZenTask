// Generated by CoffeeScript 1.12.2
(function() {
  var ExpressionParser, P, argument, combine, divide, equal, evaluate, exports, expr, factor, factory, gt, gte, lt, lte, method, minus, modulo, multiply, negate, number, operators, opf, optSep, plus, quote, sep, term1, term2, term3, term4, term5, union, variable, wrap, xparse,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  P = require('comparse');

  sep = P.space.skipMany(1);

  optSep = P.space.skipMany();

  P.prototype.within = function(p) {
    return this.between(p, p);
  };

  number = P.char('-').option('').bind(function(neg) {
    return P.digit.concat(1).bind(function(head) {
      return (P.char('.').bind(function(dot) {
        return P.digit.concat(1).bind(function(tail) {
          return P.unit(Number(neg + head + dot + tail));
        });
      })).orElse(P.unit(Number(neg + head)));
    });
  });

  variable = (P.letter.orElse(P.char('_'))).bind(function(fst) {
    return P.alphanum.concat().bind(function(rest) {
      return P.unit(fst + rest);
    });
  });

  quote = P.noneOf("'").concat().between(P.char("'"), P.char("'"));

  argument = P.choice(variable, quote, number).between(optSep, optSep);

  method = variable.bind(function(name) {
    return P.char('(').bind(function() {
      return argument.option().bind(function(arg) {
        return P.char(')').bind(function() {
          return P.unit([name, arg]);
        });
      });
    });
  });

  operators = {
    '*': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x * y;
    },
    '/': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x / y;
    },
    '%': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x % y;
    },
    '+': function(x, y) {
      if (y == null) {
        y = 0;
      }
      return x + y;
    },
    '-': function(x, y) {
      if (y == null) {
        y = 0;
      }
      return x - y;
    },
    '<': function(x, y) {
      return x < y;
    },
    '<=': function(x, y) {
      return x <= y;
    },
    '>': function(x, y) {
      return x > y;
    },
    '>=': function(x, y) {
      return x >= y;
    },
    '=': function(x, y) {
      return x === y;
    },
    '==': function(x, y) {
      return x === y;
    },
    'div': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x / y;
    },
    'mod': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x % y;
    },
    'or': function(x, y) {
      return Boolean(x || y);
    },
    '||': function(x, y) {
      return Boolean(x || y);
    },
    'and': function(x, y) {
      return Boolean(x && y);
    },
    '&&': function(x, y) {
      return Boolean(x && y);
    },
    '!': function(x) {
      return !x;
    },
    'not': function(x) {
      return !x;
    }
  };

  opf = function(op) {
    return P.unit(operators[op]);
  };

  multiply = P.char('*').within(optSep).bind(opf);

  divide = (P.char('/').within(optSep).orElse(P.string('div').within(sep))).bind(opf);

  modulo = (P.char('%').within(optSep).orElse(P.string('mod').within(sep))).bind(opf);

  plus = P.char('+').within(optSep).bind(opf);

  minus = P.char('-').within(optSep).bind(opf);

  lt = P.char('<').within(optSep).bind(opf);

  lte = P.string('<=').within(optSep).bind(opf);

  gt = P.char('>').within(optSep).bind(opf);

  gte = P.string('>=').within(optSep).bind(opf);

  equal = (P.string('==').within(optSep).orElse(P.char('=').within(optSep))).bind(opf);

  negate = (P.char('!').orElse(P.string('not').between(optSep, sep))).bind(opf);

  union = (P.char('|').concat(2).within(optSep).orElse(P.string('or').within(sep))).bind(opf);

  combine = (P.char('&').concat(2).within(optSep).orElse(P.string('and').within(sep))).bind(opf);

  evaluate = function(x, y, resolver) {
    var ref;
    x = typeof x === 'function' ? x(resolver) : x;
    y = typeof y === 'function' ? y(resolver) : y;
    return (ref = typeof this === "function" ? this(x, y) : void 0) != null ? ref : typeof resolver === "function" ? resolver(x, y) : void 0;
  };

  wrap = function(func, x, y) {
    var f, k, kind, v;
    if (y == null) {
      y = null;
    }
    kind = (function() {
      switch (false) {
        case func == null:
          return x + " " + func.name + " " + y;
        case !((x != null) && (y != null)):
          return x + "(" + y + ")";
        case x == null:
          return "" + x;
      }
    })();
    f = evaluate.bind(func, x, y);
    for (k in arguments) {
      v = arguments[k];
      f[k] = v;
    }
    Object.defineProperty(f, 'toString', {
      value: function() {
        return kind;
      }
    });
    return P.unit(f);
  };

  P.prototype.step = function(before, after) {
    return before().bind((function(_this) {
      return function(x) {
        var next;
        next = _this.bind(function(op) {
          return after().bind(function(y) {
            return wrap(op, x, y);
          });
        });
        return next.option(x);
      };
    })(this));
  };

  expr = function() {
    return union.step(term1, expr);
  };

  term1 = function() {
    return combine.step(term2, term1);
  };

  term2 = function() {
    return equal.step(term3, term2);
  };

  term3 = function() {
    return P.choice(lt, lte, gt, gte).step(term4, term3);
  };

  term4 = function() {
    return P.choice(plus, minus).step(term5, term4);
  };

  term5 = function() {
    return P.choice(multiply, divide, modulo).step(factor, term5);
  };

  factor = function() {
    return P.choice(negate.bind(function(op) {
      return factor().bind(function(f) {
        return wrap(op, f);
      });
    }), P.char('(').bind(function() {
      return optSep.bind(function() {
        return expr().bind(function(e) {
          return optSep.bind(function() {
            return P.char(')').bind(function() {
              return P.unit(e);
            });
          });
        });
      });
    }), method.bind(function(kv) {
      if (kv == null) {
        kv = [];
      }
      return wrap(null, kv[0], kv[1]);
    }), variable.bind(function(k) {
      return wrap(null, k);
    }), number, quote);
  };

  factory = function(f) {
    var p;
    p = f();
    return p.parse.bind(p);
  };

  xparse = factory(function() {
    return expr().within(optSep);
  });

  exports = module.exports = xparse['default'] = xparse;

  exports.Parser = ExpressionParser = (function(superClass) {
    extend(ExpressionParser, superClass);

    function ExpressionParser() {
      return ExpressionParser.__super__.constructor.apply(this, arguments);
    }

    ExpressionParser.create = factory;

    ExpressionParser.wrap = wrap;

    ExpressionParser.number = number;

    ExpressionParser.variable = variable;

    ExpressionParser.quote = quote;

    ExpressionParser.argument = argument;

    ExpressionParser.method = method;

    ExpressionParser.operators = operators;

    ExpressionParser.multiply = multiply;

    ExpressionParser.divide = divide;

    ExpressionParser.modulo = modulo;

    ExpressionParser.plus = plus;

    ExpressionParser.minus = minus;

    ExpressionParser.lt = lt;

    ExpressionParser.lte = lte;

    ExpressionParser.gt = gt;

    ExpressionParser.gte = gte;

    ExpressionParser.equal = equal;

    ExpressionParser.negate = negate;

    ExpressionParser.union = union;

    ExpressionParser.combine = combine;

    return ExpressionParser;

  })(P);

}).call(this);
