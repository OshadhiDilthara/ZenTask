// Generated by CoffeeScript 2.5.1
(function() {
  // # Method - controller of functions

  // ## Class Method
  var Method, Property;

  Property = require('./property');

  Method = (function() {
    class Method extends Property {
      // ### do ()

        // A convenience wrap to a Property instance that holds a function to
      // perform a Promise-based execution.

        // Always returns a Promise.
      async do(input = {}, opts = {}) {
        var ctx, e, output, ref, ref1;
        if (!((this.binding instanceof Function) || (this.data instanceof Function))) {
          return Promise.reject(this.error("cannot perform action on a property without function"));
        }
        this.debug(`[do] executing method: ${this.name}`);
        this.debug(input);
        ctx = (ref = (ref1 = this.parent) != null ? ref1.context : void 0) != null ? ref : this.context;
        ctx = ctx.with(opts, {
          path: this.path
        });
        try {
          // calling context is the parent node of the method
          input = this.schema.input.apply(input, this, {
            force: true
          });
          
          // first apply schema bound function (if availble), otherwise
          // execute assigned function (if available and not 'missing')
          if (this.binding != null) {
            if (typeof input === 'object') {
              this.debug(`[do] calling bound function with: ${Object.keys(input)}`);
            }
            this.debug(this.binding.toString());
            output = typeof this.binding === "function" ? this.binding(ctx, input) : void 0;
          } else {
            this.debug(`[do] calling assigned function: ${this.data.name}`);
            this.debug(() => {
              return this.value;
            });
            this.debug(() => {
              return this.data;
            });
            output = this.data.call(this.parent.data, input, ctx);
          }
          output = (await output);
          ({output} = this.schema.output.eval({output}, this, {
            force: true
          }));
          return output;
        } catch (error) {
          e = error;
          this.debug(e);
          return Promise.reject(e);
        }
      }

      update(value, opts) {
        if (!(value instanceof Property)) {
          return super.update(value, opts);
        }
      }

      // ### toJSON

        // This call always returns undefined for the Method node.
      toJSON(key) {
        var value;
        value = void 0;
        if (key === true) {
          value = {
            [`${this.name}`]: value
          };
        }
        return value;
      }

    };

    Method.prototype.logger = require('debug')('yang:method');

    Method.property('data', {
      set: function(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function() {
        switch (false) {
          case this.binding == null:
            return this.do.bind(this);
          default:
            return this.value;
        }
      }
    });

    return Method;

  }).call(this);

  module.exports = Method;

}).call(this);
