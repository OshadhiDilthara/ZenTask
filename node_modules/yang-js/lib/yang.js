// Generated by CoffeeScript 2.5.1
(function() {
  // # Yang - evaluable schema expression

  // This module provides support for basic set of YANG schema modeling
  // language by using the built-in *extension* syntax to define additional
  // schema language constructs. The actual YANG language [RFC
  // 6020](http://tools.ietf.org/html/rfc6020) specifications are loaded
  // inside the [main module](./main.coffee).

  // This module is the **primary interface** for consumers of this
  // library.

  // ## Dependencies
  var Expression, Extension, XPath, Yang, indent, parser,
    splice = [].splice;

  parser = require('yang-parser');

  indent = require('indent-string');

  Expression = require('./expression');

  Extension = require('./extension');

  XPath = require('./xpath');

  Yang = (function() {
    // ## Class Yang
    class Yang extends Expression {
      // ## Class-level methods
      static clear() {
        if (this.module != null) {
          this.module.splice(0, this.module.length);
        }
        if (this.submodule != null) {
          return this.submodule.splice(0, this.submodule.length);
        }
      }

      // ### parse (schema)

        // This class-level routine performs recursive parsing of passed in
      // statement and sub-statements. It provides syntactic, semantic and
      // contextual validations on the provided schema and returns the final JS
      // object tree structure as hierarchical Yang expression instances.

        // If any validation errors are encountered, it will throw the
      // appropriate error along with the context information regarding the
      // error.
      static parse(schema, opts = {}) {
        var constraint, e, kind, offender, ref, tag, yang;
        if (schema instanceof Yang) {
          return schema;
        }
        if (opts.compile == null) {
          opts.compile = true;
        }
        try {
          if (typeof schema === 'string') {
            schema = parser.parse(schema);
          }
        } catch (error) {
          e = error;
          if (!(e.offset > 50)) {
            e.offset = 50;
          }
          offender = schema.slice(e.offset - 50, e.offset + 50);
          offender = offender.replace(/\s\s+/g, ' ');
          throw this.error(`invalid YANG syntax detected around: '${offender}'`, offender);
        }
        if (!(schema instanceof Object)) {
          throw this.error("must pass in valid YANG schema", schema);
        }
        kind = (function() {
          switch (false) {
            case !schema.prf:
              return `${schema.prf}:${schema.kw}`;
            default:
              return schema.kw;
          }
        })();
        if (schema.arg !== false) {
          tag = schema.arg;
        }
        yang = (new this(kind, tag)).extends(schema.substmts.map((x) => {
          return this.parse(x, {
            compile: x.kw === 'extension'
          });
        }));
        ref = yang.scope;
        
        // perform final scoped constraint validation
        for (kind in ref) {
          constraint = ref[kind];
          if (constraint === '1' || constraint === '1..n') {
            if (!yang.hasOwnProperty(kind)) {
              throw yang.error(`constraint violation for required '${kind}' = ${constraint}`);
            }
          }
        }
        if (opts.compile) {
          yang.compile();
        }
        return yang;
      }

      // For comprehensive overview on currently supported YANG statements,
      // please refer to
      // [Compliance Report](../test/yang-compliance-coverage.md) for the latest
      // [RFC 6020](http://tools.ietf.org/html/rfc6020) YANG specification
      // compliance.

        // ### compose (data [, opts={}])

        // This call *accepts* any arbitrary JS object and it will attempt to
      // convert it into a structural `Yang` expression instance. It will
      // analyze the passed in JS data and perform best match mapping to an
      // appropriate YANG schema representation to describe the input
      // data. This method will not be able to determine conditionals or any
      // meta-data to further constrain the data, but it should provide a good
      // starting point with the resulting `Yang` expression instance.
      static compose(data, opts = {}) {
        var ext, i, len, ref, res;
        if (data == null) {
          throw this.error("must supply input 'data' to compose");
        }
        // explict compose
        if (opts.kind != null) {
          ext = Yang.prototype.lookup.call(this, 'extension', opts.kind);
          if (!(ext instanceof Expression)) {
            throw this.error(`unable to find requested '${opts.kind}' extension`);
          }
          return typeof ext.compose === "function" ? ext.compose(data, opts) : void 0;
        }
        ref = this.extension;
        // implicit compose (dynamic discovery)
        for (i = 0, len = ref.length; i < len; i++) {
          ext = ref[i];
          if (!(ext.compose instanceof Function)) {
            continue;
          }
          debug(`checking data if ${ext.tag}`);
          res = ext.compose(data, opts);
          if (res instanceof Yang) {
            return res;
          }
        }
      }

      emit(event, ...args) {
        this.emitter.emit(...arguments);
        if (event === 'change' && this !== this.root) {
          return this.root.emit(event, this);
        }
      }

      // ## Instance-level methods

        // ### compile (obj)
      compile() {
        if (!(this.source instanceof Expression)) {
          this.debug(() => {
            return this.source;
          });
          throw this.error(`encountered unknown extension '${this.kind}'`);
        }
        return super.compile(...arguments);
      }

      // ### bind (obj)

        // Every instance of `Yang` expression can be *bound* with control logic
      // which will be used during [eval](#eval-data-opts) to produce schema
      // infused **adaptive data object**. This routine is *inherited* from
      // [Class Expression](./expression.coffee).

        // This facility can be used to associate default behaviors for any
      // element in the configuration tree, as well as handler logic for
      // various YANG statements such as *rpc*, *feature*, etc.

        // This call will return the original `Yang` expression instance with the
      // new bindings registered within the `Yang` expression hierarchy.
      bind(data) {
        var binding, e, key;
        if (!this.data && (this.kind === 'module' || this.nodes.length > 0) && typeof data === 'object') {
          for (key in data) {
            binding = data[key];
            try {
              this.locate(key).bind(binding);
            } catch (error) {
              e = error;
              if (e.name === 'ExpressionError') {
                throw e;
              }
              throw this.error(`failed to bind to '${key}' (schema-path not found)`, e);
            }
          }
        } else {
          super.bind(data);
        }
        return this;
      }

      // Please refer to [Schema Binding](../TUTORIAL.md#schema-binding)
      // section of the [Getting Started Guide](../TUTORIAL.md) for usage
      // examples.

        // ### eval (data, opts={})

        // Every instance of `Yang` expression can be [eval](#eval-data-opts)
      // with arbitrary JS data input which will apply the schema against the
      // provided data and return a schema infused **adaptive** data object.

        // This is an extremely useful construct which brings out the true power
      // of YANG for defining and governing arbitrary JS data structures.

        // Basically, the input `data` will be YANG schema validated and
      // converted to a schema infused *adaptive data model* that dynamically
      // defines properties according to the schema expressions.

        // It currently supports the `opts.adaptive` parameter (default `false`)
      // which establishes a persistent binding relationship with the governing
      // `Yang` expression instance. This allows the generated model to
      // dynamically **adapt** to any changes to the governing `Yang`
      // expression instance. Refer to below [extends](#extends-schema) section
      // for additional info on how the schema can be programmatically
      // modified.
      eval(data, ctx, opts = {}) {
        if (opts.adaptive === true) {
          // TODO: this will break for 'module' which will return Model?
          this.once('change', arguments.callee.bind(this, data, opts));
        }
        return super.eval(...arguments);
      }

      // Please refer to [Working with Models](../TUTORIAL.md#working-with-models)
      // section of the [Getting Started Guide](../TUTORIAL.md) for special
      // usage examples for `module` schemas.

        // ### override (callback)

        // Perform schema source extension override to dynamically alter the
      // handling/behavior of the current schema element.
      override(callback) {
        var argument, construct, resolve, scope, transform;
        ({argument, scope, resolve, transform, construct} = this.source);
        return this.source = new Extension(this.kind, Object.assign({argument, scope, resolve, transform, construct}, callback(this.source)));
      }

      
        // ### validate (data, opts={})

        // Perform schema correctness validation for the passed in `data`.  This
      // differs from [eval](#eval-data-opts) in that the final data returned
      // is not infused as dynamic data model using Property instances. It
      // should be used to perform a sanity check on the data if it will not
      // be programmatically modified.

        // For example, [Property](./property.litcoffee) instance uses `validate`
      // when dealing with non-configurable data nodes `config false`. 
      validate(data, opts = {}) {
        return this.apply(data, null, Object.assign(opts, {
          force: true,
          preserve: true
        }));
      }

      // ### extends (schema...)

        // Every instance of `Yang` expression can be `extends` with additional
      // YANG schema string(s) and it will automatically perform
      // [parse](#parse-schema) of the provided schema text and update itself
      // accordingly.

        // This action also triggers an event emitter which will *retroactively*
      // adapt any previously [eval](#eval-data-opts) produced adaptive data
      // model instances to react accordingly to the newly changed underlying
      // schema expression(s).

        // extends() is inherited from Element
      merge(elem, opts) {
        if (typeof elem === 'string') {
          elem = Yang.parse(elem);
        }
        if (!(elem instanceof Yang)) {
          throw this.error("cannot merge invalid element into Yang", elem);
        }
        switch (elem.kind) {
          case 'type':
            return super.merge(elem, {
              append: true
            });
          case 'argument':
            return super.merge(elem, {
              replace: true
            });
          default:
            return super.merge(elem, opts);
        }
      }

      // Please refer to [Schema Extension](../TUTORIAL.md#schema-extension)
      // section of the [Getting Started Guide](../TUTORIAL.md) for usage
      // examples.
      normalizePath(ypath) {
        var lastPrefix, normalizeEntry, prefix2module, res;
        lastPrefix = null;
        prefix2module = function(root, prefix) {
          var i, j, len, len1, m, modules, ref, ref1;
          if (root.kind !== 'module') {
            return;
          }
          switch (false) {
            case root.tag !== prefix:
              return prefix;
            case root.prefix.tag !== prefix:
              return root.tag;
            default:
              ref1 = (ref = root.import) != null ? ref : [];
              for (i = 0, len = ref1.length; i < len; i++) {
                m = ref1[i];
                if (m.tag === prefix || m.prefix.tag === prefix) {
                  return m.tag;
                }
              }
              modules = root.lookup('module');
              for (j = 0, len1 = modules.length; j < len1; j++) {
                m = modules[j];
                if (m.tag === prefix || m.prefix.tag === prefix) {
                  return m.tag;
                }
              }
              return prefix; // return as-is...
          }
        };
        normalizeEntry = (x) => {
          var match, mname, prefix, target;
          if (!((x != null) && !!x)) {
            return x;
          }
          match = x.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)(?:\[.+\])?$/);
          if (match == null) {
            throw this.error(`invalid path expression '${x}' found in ${ypath}`);
          }
          [prefix, target] = [match[1], match[2]];
          switch (false) {
            case !(prefix == null):
              return target;
            case prefix !== lastPrefix:
              return target;
            default:
              lastPrefix = prefix;
              mname = prefix2module(this.root, prefix);
              return `${mname}:${target}`;
          }
        };
        ypath = ypath.replace(/\s/g, '');
        res = XPath.split(ypath).map(normalizeEntry).join('/');
        if (/^\//.test(ypath)) {
          res = '/' + res;
        }
        return res;
      }

      // ### locate (ypath)

        // This is an internal helper facility used to locate a given schema node
      // within the `Yang` schema expression tree hierarchy. It supports a
      // limited version of XPATH-like expression to locate an explicit
      // element.
      locate(ypath) {
        var i, key, kind, len, m, match, prefix, ref, ref1, ref2, ref3, rest, search, selector, tag, target;
        // TODO: figure out how to eliminate duplicate code-block section
        // shared with Element
        if (ypath == null) {
          return;
        }
        this.debug(() => {
          return `locate enter for '${ypath}'`;
        });
        if (typeof ypath === 'string') {
          if ((/^\//.test(ypath)) && this !== this.root) {
            return this.root.locate(ypath);
          }
          [key, ...rest] = this.normalizePath(ypath).split('/').filter(function(e) {
            return !!e;
          });
        } else {
          [key, ...rest] = ypath;
        }
        this.debug(() => {
          return key;
        });
        if (!((key != null) && key !== '.')) {
          return this;
        }
        if (key === '..') {
          return (ref = this.parent) != null ? ref.locate(rest) : void 0;
        }
        match = key.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)$/);
        [prefix, target] = [match[1], match[2]];
        if ((prefix != null) && this === this.root) {
          search = [target].concat(rest);
          if ((this.tag === prefix) || (this.lookup('prefix', prefix))) {
            this.debug(() => {
              return `locate (local) '/${prefix}:${search.join('/')}'`;
            });
            return super.locate(search);
          }
          ref2 = (ref1 = this.import) != null ? ref1 : [];
          for (i = 0, len = ref2.length; i < len; i++) {
            m = ref2[i];
            if (!(m.tag === prefix || m.prefix.tag === prefix)) {
              continue;
            }
            this.debug(() => {
              return `locate (external) '/${prefix}:${search.join('/')}'`;
            });
            return m.module.locate(search);
          }
          m = this.lookup('module', prefix);
          return m != null ? m.locate(search) : void 0;
        }
        this.debug(() => {
          return `checking ${target}`;
        });
        switch (false) {
          case !/^{.+}$/.test(target):
            kind = 'grouping';
            tag = target.replace(/^{(.+)}$/, '$1');
            break;
          case !/^\[.+\]$/.test(target):
            kind = 'feature';
            tag = target.replace(/^\[(.+)\]$/, '$1');
            break;
          case !/^[^(]+\([^)]*\)$/.test(target):
            target = target.match(/^([^(]+)\((.*)\)$/);
            [kind, tag] = [target[1], target[2]];
            if (!tag) {
              tag = void 0;
            }
            break;
          case !/^\<.+\>$/.test(target):
            target = target.replace(/^\<(.+)\>$/, '$1');
            ref3 = target.split(':'), [...kind] = ref3, [tag] = splice.call(kind, -1);
            [tag, selector] = tag.split('=');
            if (kind != null ? kind.length : void 0) {
              kind = kind[0];
            }
            break;
          default:
            return super.locate([key].concat(rest));
        }
        this.debug(() => {
          return `matching ${kind} ${tag}`;
        });
        match = this.match(kind, tag);
        switch (false) {
          case rest.length !== 0:
            return match;
          case !Array.isArray(match):
            return match.map(function(x) {
              return x.locate(rest);
            }).filter(Boolean);
          default:
            return match != null ? match.locate(rest) : void 0;
        }
      }

      // ### match (kind, tag)

        // This is an internal helper facility used by [locate](#locate-ypath) and
      // [lookup](./element.litcoffee#lookup-kind-tag) to test whether a given
      // entity exists in the local schema tree.

        // Yang Expression can support 'tag' with prefix to another module
      // (or itself).
      match(kind, tag) {
        var arg, ctx, i, imports, len, m, module, prefix, ref, ref1, ref2, ref3, ref4, ref5, res;
        if (!((kind != null) && (tag != null) && typeof tag === 'string')) {
          return super.match(...arguments);
        }
        res = super.match(...arguments);
        if (res != null) {
          return res;
        }
        ref = tag.split(':'), [...prefix] = ref, [arg] = splice.call(prefix, -1);
        if (!prefix.length) {
          return;
        }
        this.debug(() => {
          return `[match] with ${kind} ${tag}`;
        });
        prefix = prefix[0];
        this.debug(() => {
          return "[match] check if current module's prefix";
        });
        if (this.root.tag === prefix || ((ref1 = this.root.prefix) != null ? ref1.tag : void 0) === prefix) {
          return this.root.match(kind, arg);
        }
        this.debug(() => {
          return "[match] checking if submodule's parent";
        });
        ctx = this.lookup('belongs-to');
        if ((ctx != null ? ctx.prefix.tag : void 0) === prefix) {
          return (ref2 = ctx.module) != null ? ref2.match(kind, arg) : void 0;
        }
        this.debug(() => {
          return "[match] check if one of current module's imports";
        });
        imports = (ref3 = (ref4 = this.root) != null ? ref4.import : void 0) != null ? ref3 : [];
        for (i = 0, len = imports.length; i < len; i++) {
          m = imports[i];
          if (!(m.prefix.tag === prefix)) {
            continue;
          }
          this.debug(() => {
            return `[match] checking ${m.tag}`;
          });
          return (ref5 = m.module) != null ? ref5.match(kind, arg) : void 0;
        }
        this.debug(() => {
          return "[match] check if one of available modules";
        });
        module = this.lookup('module', prefix);
        if (module != null) {
          return module.match(kind, arg);
        }
      }

      // ### toString (opts={})

        // The current `Yang` expression will covert back to the equivalent YANG
      // schema text format.

        // At first glance, this may not seem like a useful facility since YANG
      // schema text is *generally known* before [parse](#parse-schema) but it
      // becomes highly relevant when you consider a given `Yang` expression
      // programatically changing via [extends](#extends-schema).

        // Currently it supports `space` parameter which can be used to specify
      // number of spaces to use for indenting YANG statement blocks.  It
      // defaults to **2** but when set to **0**, the generated output will
      // omit newlines and other spacing for a more compact YANG output.
      toString(opts = {
          space: 2
        }) {
        var s, sub;
        s = this.kind;
        if (this.argument != null) {
          s += ' ' + (function() {
            switch (this.argument) {
              case 'value':
                switch (false) {
                  case !Array.isArray(this.tag):
                    return `'${this.tag.join(' ')}'`;
                  default:
                    return `'${this.tag}'`;
                }
                break;
              case 'text':
                return "\n" + (indent('"' + this.tag + '"', ' ', opts.space));
              default:
                return this.tag;
            }
          }).call(this);
        }
        sub = this.children.filter((x) => {
          return x.parent === this;
        }).map(function(x) {
          return x.toString(opts);
        }).join("\n");
        if (!!sub) {
          s += " {\n" + (indent(sub, ' ', opts.space)) + "\n}";
        } else {
          s += ';';
        }
        return s;
      }

      // ### toJSON

        // The current `Yang` expression will convert into a simple JS object
      // format.

        // toJSON() is inherited from Element

        // ### valueOf

        // The current 'Yang' expression will convert into a primitive form for
      // comparision purposes.
      valueOf() {
        switch (this.argument) {
          case 'value':
          case 'text':
            return this.tag.valueOf();
          default:
            return this;
        }
      }

    };

    Yang.prototype.logger = require('debug')('yang:schema');

    Yang.scope = {
      extension: '0..n',
      typedef: '0..n',
      module: '0..n',
      submodule: '0..n'
    };

    // This facility is a powerful construct to dynamically generate `Yang`
    // schema from ordinary JS objects. For additional usage examples, please
    // refer to [Dynamic Composition](../TUTORIAL.md#dynamic-composition)
    // section in the [Getting Started Guide](../TUTORIAL.md).

    // ## Main constructor

    // The constructor inherits from `Expression` which returns a `bound
    // function` that invokes [eval](#eval-data-opts) when called.
    Yang.property('source', {
      get: function() {
        var base;
        if ((base = this.state).source == null) {
          base.source = this.lookup('extension', this.kind);
        }
        return this.state.source || {};
      },
      set: function(value) {
        return this.state.source = value;
      }
    });

    Yang.property('datakey', {
      get: function() {
        var ref;
        switch (false) {
          case !(this.parent instanceof Yang && this.parent.kind === 'module'):
            return `${this.parent.tag}:${this.tag}`;
          case !(this.parent instanceof Yang && this.parent.kind === 'submodule'):
            return `${this.parent['belongs-to'].tag}:${this.tag}`;
          case !(this.node && this.external && !this.state.relative):
            return `${this.origin.root.tag}:${this.tag}`;
          default:
            return (ref = this.tag) != null ? ref : this.kind;
        }
      }
    });

    Yang.property('external', {
      get: function() {
        return (this.origin != null) && this.origin.root !== this.root && this.origin.root.kind === 'module';
      }
    });

    Yang.property('datapath', {
      get: function() {
        var label, ref;
        if (this.kind === 'module') {
          return '';
        }
        label = this.node ? this.datakey : `${this.kind}(${this.datakey})`;
        switch (false) {
          case ((ref = this.parent) != null ? ref.datapath : void 0) == null:
            return [this.parent.datapath, label].join('/');
          default:
            return label;
        }
      }
    });

    return Yang;

  }).call(this);

  // Please refer to [Schema Conversion](../TUTORIAL.md#schema-conversion)
  // section of the [Getting Started Guide](../TUTORIAL.md) for usage
  // examples.

  // ## Export Yang Class
  module.exports = Yang;

}).call(this);
