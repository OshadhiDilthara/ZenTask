// Generated by CoffeeScript 2.5.1
(function() {
  // # Element - cascading element tree

  // ## Class Element
  var Element, Emitter, debug, delegate, kCache, kIndex, logger,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf;

  debug = require('debug');

  logger = debug('yang:element');

  delegate = require('delegates');

  Emitter = require('events').EventEmitter;

  Emitter.defaultMaxListeners = 100;

  kIndex = Symbol.for('element:index');

  kCache = Symbol.for('element:cache');

  Element = (function() {
    class Element {
      static property(prop, desc) {
        return Object.defineProperty(this.prototype, prop, desc);
      }

      static use() {
        var res;
        res = [].concat(...arguments).filter(function(x) {
          return x != null;
        }).map((elem) => {
          var e, exists;
          exists = Element.prototype.match.call(this, elem.kind, elem.tag);
          if (exists != null) {
            this.debug(() => {
              return `use: using previously loaded '${elem.kind}:${elem.tag}'`;
            });
            return exists;
          }
          try {
            return Element.prototype.merge.call(this, elem);
          } catch (error) {
            e = error;
            throw this.error(`use: unable to merge '${elem.kind}:${elem.tag}'`, e);
          }
        });
        switch (false) {
          case !(res.length > 1):
            return res;
          case res.length !== 1:
            return res[0];
          default:
            return void 0;
        }
      }

      static debug(f) {
        switch (false) {
          case !debug.enabled(this.logger.namespace):
            switch (false) {
              case typeof f !== 'function':
                return this.logger(this.uri, ...[].concat(f()));
              default:
                return this.logger(this.uri, ...arguments);
            }
        }
      }

      static error(err, ctx) {
        if (!(err instanceof Error)) {
          err = new Error(err);
        }
        err.uri = this.uri;
        err.src = this;
        err.ctx = ctx;
        return err;
      }

      constructor(kind1, tag1, scope) {
        this.kind = kind1;
        this.tag = tag1;
        if (this.kind == null) {
          throw this.error("must supply 'kind' to create a new Element");
        }
        if (scope != null) {
          this.scope = scope;
        }
        Object.defineProperties(this, {
          parent: {
            value: null,
            writable: true
          },
          origin: {
            value: null,
            writable: true
          },
          state: {
            value: {},
            writable: true
          },
          [kIndex]: {
            value: 0,
            writable: true
          },
          emitter: {
            value: new Emitter()
          }
        });
      }

      // ## Instance-level methods

        // ### clone
      clone(opts = {}) {
        var copy, origin, relative;
        ({origin = this.origin, relative = true} = opts);
        this.debug(() => {
          return `cloning ${this.kind}:${this.tag} with ${this.children.length} elements`;
        });
        copy = (new this.constructor(this.kind, this.tag, this.source)).extends(this.children.map(function(x) {
          return x.clone(opts);
        }));
        copy.state = Object.create(this.state);
        copy.state.relative = relative;
        copy.origin = origin != null ? origin : this;
        return copy;
      }

      // ### extends (elements...)

        // This is the primary mechanism for defining sub-elements to become part
      // of the element tree
      extends() {
        var elems;
        elems = ([].concat(...arguments)).filter(function(x) {
          return (x != null) && !!x;
        });
        if (!(elems.length > 0)) {
          return this;
        }
        elems.forEach((expr) => {
          return this.merge(expr);
        });
        this.emit('change', ...elems);
        return this;
      }

      // ### merge (element)

        // This helper method merges a specific Element into current Element
      // while performing `@scope` validations.
      merge(elem, opts = {}) {
        var _merge, exists;
        if (!(elem instanceof Element)) {
          throw this.error("cannot merge invalid element into Element", elem);
        }
        elem.parent = this;
        if (this.children != null) {
          elem[kIndex] = this.children.length;
        }
        this[kCache] = null;
        _merge = function(item) {
          var i, j, len, ref, ref1, ref2, x;
          if (!item.node || opts.append || (ref = item.datakey, indexOf.call((ref1 = this.keys) != null ? ref1 : [], ref) < 0)) {
            this.push(item);
            return true;
          } else if (opts.replace === true) {
            ref2 = this;
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              x = ref2[i];
              if (!(x.datakey === item.datakey)) {
                continue;
              }
              this.splice(i, 1, item);
              break;
            }
            return true;
          } else {
            return false;
          }
        };
        if (this.scope == null) {
          if (!this.hasOwnProperty(elem.kind)) {
            this[elem.kind] = elem;
            return elem;
          }
          if (!Array.isArray(this[elem.kind])) {
            exists = this[elem.kind];
            this[elem.kind] = [exists];
            Object.defineProperty(this[elem.kind], 'keys', {
              get: (function() {
                return this.map(function(x) {
                  return x.datakey;
                });
              }).bind(this[elem.kind])
            });
          }
          if (!_merge.call(this[elem.kind], elem)) {
            throw this.error(`constraint violation for '${elem.kind} ${elem.datakey}' - cannot define more than once`);
          }
          return elem;
        }
        if (!(elem.kind in this.scope)) {
          if ((elem.scope != null) && (!elem.source.state.unbound && !this.source.state.unbound)) {
            this.debug(() => {
              return this.scope;
            });
            throw this.error(`scope violation - invalid '${elem.kind}' extension found`);
          } else {
            this.scope[elem.kind] = '*'; // this is hackish...
          }
        }
        switch (this.scope[elem.kind]) {
          case '0..n':
          case '1..n':
          case '*':
            if (!this.hasOwnProperty(elem.kind)) {
              this[elem.kind] = [];
              Object.defineProperty(this[elem.kind], 'keys', {
                get: (function() {
                  return this.map(function(x) {
                    return x.datakey;
                  });
                }).bind(this[elem.kind])
              });
            }
            if (!Array.isArray(this[elem.kind])) {
              exists = this[elem.kind];
              this[elem.kind] = [exists];
              Object.defineProperty(this[elem.kind], 'keys', {
                get: (function() {
                  return this.map(function(x) {
                    return x.datakey;
                  });
                }).bind(this[elem.kind])
              });
            }
            if (!_merge.call(this[elem.kind], elem)) {
              throw this.error(`constraint violation for '${elem.kind} ${elem.datakey}' - already defined`);
            }
            break;
          case '0..1':
          case '1':
            if (!this.hasOwnProperty(elem.kind)) {
              this[elem.kind] = elem;
            } else if (opts.replace === true) {
              this.debug(() => {
                return `replacing pre-existing ${elem.kind}`;
              });
              this[elem.kind] = elem;
            } else {
              throw this.error(`constraint violation for '${elem.kind}' - cannot define more than once`);
            }
            break;
          default:
            throw this.error(`unrecognized scope constraint defined for '${elem.kind}' with ${this.scope[elem.kind]}`);
        }
        return elem;
      }

      removes() {
        var elems;
        elems = ([].concat(...arguments)).filter(function(x) {
          return (x != null) && !!x;
        });
        if (!(elems.length > 0)) {
          return this;
        }
        elems.forEach((expr) => {
          return this.remove(expr);
        });
        this.emit('change', ...elems);
        return this;
      }

      remove(elem) {
        var exists;
        if (!(elem instanceof Element)) {
          throw this.error("cannot remove a non-Element from an Element", elem);
        }
        exists = Element.prototype.match.call(this, elem.kind, elem.datakey);
        if (exists == null) {
          return this;
        }
        if (Array.isArray(this[elem.kind])) {
          this[elem.kind] = this[elem.kind].filter(function(x) {
            return x.datakey !== elem.datakey;
          });
          if (!this[elem.kind].length) {
            delete this[elem.kind];
          }
        } else {
          delete this[elem.kind];
        }
        this[kCache] = null;
        return this;
      }

      // ### update (element)

        // This alternative form of [merge](#merge-element) performs conditional
      // merge based on existence check. It is considered *safer* alternative
      // to direct [merge](#merge-element) call.

        // performs conditional merge based on existence
      update(elem) {
        var exists, j, len, ref, target;
        if (!(elem instanceof Element)) {
          throw this.error("cannot update a non-Element into an Element", elem);
        }
        //@debug => "update with #{elem.kind}/#{elem.tag}"
        exists = (function() {
          switch (false) {
            case elem.tag == null:
              return Element.prototype.match.call(this, elem.kind, elem.datakey);
            default:
              return Element.prototype.match.call(this, elem.kind);
          }
        }).call(this);
        if (exists == null) {
          return this.merge(elem);
        }
        ref = elem.children;
        for (j = 0, len = ref.length; j < len; j++) {
          target = ref[j];
          //@debug => "update #{exists.kind} in-place for #{elem.children.length} elements"
          exists.update(target);
        }
        return exists;
      }

      // Looks for matching Elements using kind and tag
      // Direction: up the hierarchy (towards root)
      lookup(kind, tag) {
        var res;
        //@debug => "lookup: #{kind}(#{tag})..."
        res = (function() {
          switch (false) {
            case !(!(this instanceof Object)):
              return void 0;
            case !(this instanceof Element):
              return this.match(kind, tag);
            default:
              return Element.prototype.match.call(this, kind, tag);
          }
        }).call(this);
        if (res == null) {
          res = (function() {
            switch (false) {
              case this.origin == null:
                return Element.prototype.lookup.apply(this.origin, arguments);
              case this.parent == null:
                return Element.prototype.lookup.apply(this.parent, arguments);
              default:
                return Element.prototype.match.call(this.constructor, kind, tag);
            }
          }).apply(this, arguments);
        }
        //@debug => "lookup: #{kind}(#{tag}) got result: #{res?}"
        return res;
      }

      // Looks for matching Elements using YPATH notation
      // Direction: down the hierarchy (away from root)
      at() {
        return this.locate(...arguments);
      }

      locate(ypath) {
        var key, match, ref, rest;
        if (ypath == null) {
          return;
        }
        if (typeof ypath === 'string') {
          this.debug(() => {
            return `locate: ${ypath}`;
          });
          ypath = ypath.replace(/\s/g, '');
          if ((/^\//.test(ypath)) && this !== this.root) {
            return this.root.locate(ypath);
          }
          [key, ...rest] = ypath.split('/').filter(function(e) {
            return !!e;
          });
        } else {
          this.debug(() => {
            return `locate: ${ypath.join('/')}`;
          });
          [key, ...rest] = ypath;
        }
        if (key == null) {
          return this;
        }
        match = (function() {
          switch (false) {
            case key !== '..':
              return this.match(key);
            default:
              return this.match('*', key);
          }
        }).call(this);
        if ((ref = this.scope[key]) === '0..1' || ref === '1') {
          if (match == null) {
            match = this.match(key);
          }
        }
        switch (false) {
          case !(rest.length > 0):
            return match != null ? match.locate(rest) : void 0;
          default:
            return match;
        }
      }

      // Looks for a matching Element(s) in immediate sub-elements
      match(kind, tag) {
        var elem, j, len, match;
        if (!((kind != null) && (this[kind] != null))) {
          return;
        }
        if (tag == null) {
          return this[kind];
        }
        match = this[kind];
        if (!(match instanceof Array)) {
          match = [match];
        }
        if (tag === '*') {
          return match;
        }
        for (j = 0, len = match.length; j < len; j++) {
          elem = match[j];
          if (elem instanceof Element) {
            if (tag === elem.datakey || tag === elem.tag) {
              return elem;
            }
          }
        }
        return void 0;
      }

      // ### toJSON

        // Converts the Element into a JS object
      toJSON(opts = {
          tag: true,
          extended: false
        }) {
        var sub;
        //@debug => "converting #{@kind} toJSON with #{@children.length}"
        sub = this.children.filter((x) => {
          return opts.extended || x.parent === this;
        }).reduce((function(a, b) {
          var k, kk, ref, v, vv;
          ref = b.toJSON();
          for (k in ref) {
            v = ref[k];
            if (a[k] instanceof Object) {
              if (v instanceof Object) {
                for (kk in v) {
                  vv = v[kk];
                  a[k][kk] = vv;
                }
              }
            } else {
              a[k] = v;
            }
          }
          return a;
        }), {});
        if (opts.tag) {
          return {
            [`${this.kind}`]: (function() {
              switch (false) {
                case !(Object.keys(sub).length > 0):
                  if (this.tag != null) {
                    return {
                      [`${this.tag}`]: sub
                    };
                  } else {
                    return sub;
                  }
                  break;
                case !(this.tag instanceof Object):
                  return `${this.tag}`;
                default:
                  return this.tag;
              }
            }).call(this)
          };
        } else {
          return sub;
        }
      }

    };

    Element.logger = logger;

    Element.prototype.logger = Element.logger;

    Element.prototype.debug = Element.debug;

    Element.prototype.error = Element.error;

    delegate(Element.prototype, 'emitter').method('emit').method('once').method('on').method('off');

    // ### Computed Properties
    Element.property('datakey', {
      get: function() {
        var ref;
        return (ref = this.tag) != null ? ref : this.kind;
      }
    });

    Element.property('uri', {
      get: function() {
        var mark, ref, ref1;
        switch (false) {
          case !(this.parent instanceof Element):
            mark = this.kind;
            if ((this.tag != null) && ((ref = (ref1 = this.parent.scope) != null ? ref1[this.kind] : void 0) === '0..n' || ref === '1..n' || ref === '*')) {
              mark += `(${this.tag})`;
            }
            return `${this.parent.uri}/${mark}`;
          case this.tag == null:
            return `${this.kind}(${this.tag})`;
          default:
            return this.kind;
        }
      }
    });

    Element.property('root', {
      get: function() {
        switch (false) {
          case !(this.parent instanceof Element):
            return this.parent.root;
          case !(this.origin instanceof Element):
            return this.origin.root;
          default:
            return this;
        }
      }
    });

    Element.property('children', {
      get: function() {
        var elements, k, v;
        if (this[kCache] == null) {
          elements = ((function() {
            var ref, results;
            ref = this;
            results = [];
            for (k in ref) {
              if (!hasProp.call(ref, k)) continue;
              v = ref[k];
              if (k !== 'parent' && k !== 'origin' && k !== 'tag' && k !== kCache && k !== 'source') {
                results.push(v);
              }
            }
            return results;
          }).call(this)).reduce((function(a, b) {
            switch (false) {
              case !(b instanceof Element):
                return a.concat(b);
              case !(b instanceof Array):
                return a.concat(b.filter(function(x) {
                  return x instanceof Element;
                }));
              default:
                return a;
            }
          }), []);
          this[kCache] = elements.sort(function(a, b) {
            return a[kIndex] - b[kIndex];
          });
        }
        return this[kCache];
      }
    });

    Element.property('*', {
      get: function() {
        return this.children;
      }
    });

    Element.property('..', {
      get: function() {
        return this.parent;
      }
    });

    return Element;

  }).call(this);

  // ## Export Element Class
  module.exports = Element;

}).call(this);
