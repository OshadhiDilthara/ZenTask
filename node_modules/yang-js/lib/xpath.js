// Generated by CoffeeScript 2.5.1
(function() {
  var Expression, Filter, XPath, exports, xparse;

  Expression = require('./expression');

  xparse = require('xparse');

  Filter = (function() {
    class Filter extends Expression {
      constructor(pattern = '') {
        var source;
        source = {
          argument: 'predicate',
          scope: {},
          transform: function(prop) {
            var expr, props;
            expr = this.tag;
            switch (typeof expr) {
              case 'number':
                return prop.props[expr - 1];
              case 'string':
                return prop.children.get(`key(${expr})`);
              default:
                props = (function() {
                  switch (false) {
                    case prop.kind !== 'list':
                      return prop.props;
                    default:
                      return [prop];
                  }
                })();
                return props.filter(function(prop) {
                  return expr(function(name, arg) {
                    var elem;
                    elem = prop.data;
                    if (arg == null) {
                      return elem[name];
                    }
                    switch (name) {
                      case 'current':
                        return elem;
                      case 'false':
                        return false;
                      case 'true':
                        return true;
                      case 'key':
                        return arg;
                      case 'name':
                        return elem[arg];
                    }
                  });
                });
            }
          }
        };
        super('filter', xparse(pattern), source);
        this.pattern = pattern;
      }

      clone() {
        return new this.constructor(this.pattern);
      }

      toString() {
        return this.pattern;
      }

    };

    Filter.prototype.logger = require('debug')('yang:xpath:filter');

    return Filter;

  }).call(this);

  XPath = (function() {
    class XPath extends Expression {
      static split(pattern) {
        var elements;
        elements = pattern.match(/([^\/^\[]*(?:\[.+?\])*)/g);
        if (elements == null) {
          elements = [];
        }
        elements = elements.filter(function(x) {
          return !!x;
        });
        return elements;
      }

      constructor(pattern, schema) {
        var e, elements, match, predicates, source, target;
        if (pattern instanceof XPath) {
          return pattern;
        }
        if (typeof pattern !== 'string') {
          throw new Error("must pass in 'pattern' as valid string");
        }
        elements = XPath.split(pattern);
        if (/^\//.test(pattern)) {
          target = '/';
          if (schema instanceof Expression) {
            schema = schema.root;
          }
          predicates = [];
        } else {
          if (!(elements.length > 0)) {
            throw new Error(`unable to process '${pattern}' (please check your input)`);
          }
          [target, ...predicates] = elements.shift().split(/\[\s*(.+?)\s*\]/);
          if (target == null) {
            throw new Error(`unable to process '${pattern}' (missing axis)`);
          }
          predicates = predicates.filter(function(x) {
            return !!x;
          });
          if (schema instanceof Expression) {
            try {
              match = schema.locate(target);
            } catch (error) {
              e = error;
              console.warn(e);
            }
            if (match == null) {
              switch (schema.kind) {
                case 'list':
                  predicates.unshift((function() {
                    switch (false) {
                      case schema.key == null:
                        return `'${target}'`;
                      default:
                        return target;
                    }
                  })());
                  target = '.';
                  break;
                case 'anydata':
                  schema = void 0;
                  break;
                default:
                  throw new Error(`unable to locate '${target}' inside schema: ${schema.uri}`);
              }
            } else {
              schema = match;
              if (!/^\./.test(target)) {
                target = schema.datakey;
              }
            }
          }
        }
        source = {
          argument: 'node',
          scope: {
            filter: '0..n',
            xpath: '0..1'
          },
          transform: function(data) {
            return this.process(data);
          }
        };
        super('xpath', target, source);
        if (schema instanceof Expression) {
          Object.defineProperty(this, 'schema', {
            value: schema
          });
        }
        if (predicates.length > 0) {
          this.extends(...(predicates.map(function(x) {
            return new Filter(x);
          })));
        }
        if (elements.length > 0) {
          this.extends(elements.join('/'));
        }
      }

      process(data) {
        var ref, ref1;
        this.debug(`[${this.tag}] process using schema from ${(ref = this.schema) != null ? ref.kind : void 0}:${(ref1 = this.schema) != null ? ref1.tag : void 0}`);
        if (!(data instanceof Object)) {
          return [];
        }
        // 1. find all matching props
        data = [].concat(data);
        data = data.reduce(((a, prop) => {
          return a.concat(this.match(prop));
        }), []);
        if ((this.xpath != null) && data.length) {
          return this.xpath.eval(data);
        }
        this.debug(`[${this.tag}] returning ${data.length} properties`);
        // @debug data
        return data;
      }

      match(prop) {
        var expr, i, len, ref, result;
        // console.warn('MATCH', @tag, prop.children);
        result = (function() {
          switch (false) {
            case this.tag !== '/':
              return prop.root;
            case this.tag !== '.':
              return prop;
            case this.tag !== '..':
              return prop.parent;
            case this.tag !== '*':
              return prop.props;
            case !prop.children.has(this.tag):
              return prop.children.get(this.tag);
            case prop.kind !== 'list':
              return prop.props.map((li) => {
                return li.children.get(this.tag);
              });
            case this.schema == null:
              return prop.children.get(this.schema.datakey);
          }
        }).call(this);
        result = [].concat(result).filter(Boolean);
        if (this.filter != null) {
          ref = this.filter;
          for (i = 0, len = ref.length; i < len; i++) {
            expr = ref[i];
            if (!result.length) {
              break;
            }
            result = result.reduce((function(a, b) {
              return a.concat(expr.eval(b)).filter(Boolean);
            }), []);
          }
        }
        return result;
      }

      clone() {
        var ref, schema;
        schema = this.tag === '/' ? this.schema : (ref = this.parent) != null ? ref.schema : void 0;
        return (new this.constructor(this.tag, schema)).extends(this.exprs.map(function(x) {
          return x.clone();
        }));
      }

      merge(elem) {
        elem = (function() {
          switch (false) {
            case !(elem instanceof Expression):
              return elem;
            default:
              return new XPath(elem, this.schema);
          }
        }).call(this);
        if (elem.tag === '.') {
          this.extends(elem.filter, elem.xpath);
          return this;
        } else {
          return super.merge(elem);
        }
      }

      // returns the XPATH instance found matching the `pattern`
      locate(pattern) {
        try {
          if (!(pattern instanceof XPath)) {
            pattern = new XPath(pattern, this.schema);
          }
          if (this.tag !== pattern.tag) {
            return;
          }
          if (!((pattern.filter == null) || `${this.filter}` === `${pattern.filter}`)) {
            return;
          }
          switch (false) {
            case !((this.xpath != null) && (pattern.xpath != null)):
              return this.xpath.locate(pattern.xpath);
            case pattern.xpath == null:
              return void 0;
            default:
              return this;
          }
        } catch (error) {}
      }

      // trims the current XPATH expressions after matching `pattern`
      trim(pattern) {
        var match;
        match = this.locate(pattern);
        if (match != null) {
          delete match.xpath;
        }
        return this;
      }

      // append a new pattern at the tail of the current XPATH expression
      append(pattern) {
        this.tail.merge(pattern);
        return this;
      }

      // returns the XPATH `pattern` that matches part or all of this XPATH instance
      contains(...patterns) {
        var i, len, pattern;
        for (i = 0, len = patterns.length; i < len; i++) {
          pattern = patterns[i];
          if (this.locate(pattern) != null) {
            return pattern;
          }
        }
      }

      toString() {
        var filter, i, len, ref, s;
        s = this.tag === '/' ? '' : this.tag;
        if (this.filter != null) {
          ref = this.filter;
          for (i = 0, len = ref.length; i < len; i++) {
            filter = ref[i];
            s += `[${filter}]`;
          }
        }
        if (this.xpath != null) {
          s += `/${this.xpath}`;
        }
        if (!s) {
          s = this.tag;
        }
        return s;
      }

    };

    XPath.prototype.logger = require('debug')('yang:xpath');

    XPath.property('tail', {
      get: function() {
        var end;
        end = this;
        while (end.xpath != null) {
          end = end.xpath;
        }
        return end;
      }
    });

    return XPath;

  }).call(this);

  exports = module.exports = XPath;

  exports.Filter = Filter;

  exports.parse = function(pattern, schema) {
    return new XPath(pattern, schema);
  };

}).call(this);
