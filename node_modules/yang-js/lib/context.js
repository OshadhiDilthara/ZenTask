// Generated by CoffeeScript 2.5.1
(function() {
  // Context - control logic binding context

  //# Context Object
  var debug, delegate, proto;

  debug = require('debug')('yang:context');

  delegate = require('delegates');

  proto = module.exports = {
    use: function(name) {
      var ref;
      // TODO: below is a bit of a hack...
      return (ref = this.lookup('feature', name)) != null ? ref.binding : void 0;
    },
    with: function(...options) {
      var ctx;
      ctx = Object.create(this);
      ctx.opts = Object.assign({}, this.opts, ...options);
      Object.preventExtensions(ctx);
      return ctx;
    },
    at: function(key) {
      var node;
      node = this.node.in(key);
      if (node == null) {
        throw this.error(`unable to access ${key}`);
      }
      return node.context.with(this.opts);
    },
    push: async function(data) {
      var err, opts, ref;
      if ((ref = this.kind) === 'rpc' || ref === 'action') {
        return this.node.do(data, this.opts);
      }
      opts = Object.assign({}, this.opts); // make a copy
      try {
        ((await this.node.lock(opts))).merge(data, opts);
      } catch (error) {
        err = error;
        this.node.unlock(opts);
        throw this.error(err);
      }
      try {
        await this.node.commit(opts);
      } catch (error) {
        err = error;
        throw this.error(err);
      }
      return this.node;
    },
    
    // convenience function for replace (set operation)
    replace: function(data) {
      return this.with({
        replace: true
      }).push(data);
    },
    set: function(data) {
      return this.node.set(data, Object.assign({}, this.opts));
    },
    merge: function(data) {
      return this.node.merge(data, Object.assign({}, this.opts));
    },
    commit: function() {
      return this.node.commit(Object.assign({}, this.opts));
    },
    revert: function() {
      return this.node.revert(Object.assign({}, this.opts));
    },
    after: function(timeout, max) {
      timeout = parseInt(timeout) || 100;
      max = parseInt(max) || 5000;
      return new Promise(function(resolve) {
        return setTimeout((function() {
          return resolve(Math.round(Math.min(max, timeout * 1.5)));
        }), timeout);
      });
    },
    logDebug: function() {
      return this.log('debug', ...arguments);
    },
    logInfo: function() {
      return this.log('info', ...arguments);
    },
    logWarn: function() {
      return this.log('warn', ...arguments);
    },
    logError: function() {
      return this.log('error', this.error(...arguments));
    },
    log: function(topic, ...args) {
      return this.root.emit('log', topic, args, this);
    }
  };

  //# Property node delegation
  delegate(proto, 'node').access('data').getter('prior').getter('delta').getter('value').getter('root').getter('parent').getter('schema').getter('uri').getter('name').getter('kind').getter('path').getter('active').getter('attached').getter('changed').getter('changes').getter('change').getter('delta').method('get').method('error').method('locate').method('lookup').method('find').method('inspect').method('toJSON'); // read/write with validations // used for instance-identifier and leafref validations // boolean // Set of changed properties // Object of uncommitted changes // Object of latest change snapshot

  //# Module delegation
  delegate(proto, 'root').method('access');

}).call(this);
