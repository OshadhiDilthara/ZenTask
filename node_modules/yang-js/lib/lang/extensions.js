// Generated by CoffeeScript 2.5.1
(function() {
  var ARGUMENT_NAMES, Arguments, Container, Extension, List, Method, Model, Notification, Property, STRIP_COMMENTS, XPath, Yang, assert,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf;

  ({Yang, Extension, XPath, Model, Container, List, Method, Notification, Property} = require('..'));

  Arguments = require('./arguments');

  assert = require('assert');

  STRIP_COMMENTS = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/mg;

  ARGUMENT_NAMES = /([^\s,]+)/g;

  module.exports = [
    new Extension('action',
    {
      argument: 'name',
      scope: {
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        input: '0..1',
        output: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n'
      },
      predicate: function(data = function() {}) {
        return assert(data instanceof Function,
    "data must contain a valid instanceof Function");
      },
      resolve: function() {
        if (!this.input) {
          this.extends(new Yang('input'));
        }
        if (!this.output) {
          return this.extends(new Yang('output'));
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var expr,
    i,
    len,
    ref1;
        if (data == null) {
          return;
        }
        if (!(data instanceof Function)) {
          this.debug(() => {
            return data;
          });
          // TODO: allow data to be a 'string' compiled into a Function?
          throw this.error(`expected a function but got a '${typeof data}'`);
        }
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          data = expr.eval(data,
    ctx,
    opts);
        }
        return data;
      },
      construct: function() {
        return (new Method({
          name: this.tag,
          schema: this
        })).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var expr,
    i,
    kind,
    len,
    match,
    matches,
    possibilities;
        if (!(data instanceof Function)) {
          return;
        }
        if (Object.keys(data).length !== 0) {
          return;
        }
        if (!((data.prototype == null) || Object.keys(data.prototype).length === 0)) {
          return;
        }
        possibilities = (function() {
          var ref1,
    results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension',
    kind));
          }
          return results;
        }).call(this);
        matches = [];
        for (i = 0, len = possibilities.length; i < len; i++) {
          expr = possibilities[i];
          if (!(expr != null)) {
            continue;
          }
          match = typeof expr.compose === "function" ? expr.compose(data) : void 0;
          if (match != null) {
            matches.push(match);
          }
        }
        return (new Yang(this.tag,
    opts.tag,
    this)).extends(...matches);
      }
    }),
    new Extension('anydata',
    {
      argument: 'name',
      data: true,
      scope: {
        config: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        must: '0..n',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      construct: function() {
        return (new Property(this)).attach(...arguments);
      }
    }),
    new Extension('anyxml',
    {
      argument: 'name',
      data: true,
      scope: {
        config: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        must: '0..n',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      construct: function() {
        return (new Property(this)).attach(...arguments);
      }
    }),
    new Extension('argument',
    {
      argument: 'arg-type',
      scope: {
        'yin-element': '0..1'
      }
    }),
    new Extension('augment',
    {
      argument: 'target-node',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        case: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        reference: '0..1',
        status: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      resolve: function() {
        var target;
        target = (function() {
          switch (this.parent.kind) {
            case 'module':
              if (!/^\//.test(this.tag)) {
                throw this.error(`'${this.tag}' must be absolute-schema-path to augment within module statement`);
              }
              return this.locate(this.tag);
            default:
              if (!/^[_0-9a-zA-Z]/.test(this.tag)) {
                throw this.error(`'${this.tag}' must be relative-schema-path to augment within uses statement`);
              }
              return this.parent.state.grouping.locate(this.tag);
          }
        }).call(this);
        if (target == null) {
          console.warn(this.error(`unable to locate '${this.tag}'`));
          return;
        }
        if (this.when == null) {
          return this.once('compiled',
    () => {
            this.debug(() => {
              return `augmenting '${target.kind}:${target.tag}'`;
            });
            return target.extends(this.nodes.map((x) => {
              return x.clone({
                origin: this,
                relative: false
              });
            }));
          });
        } else {
          return target.on('transformed',
    (data) => {
            var expr,
    i,
    len,
    ref1,
    results;
            if (data != null) {
              ref1 = this.exprs;
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                expr = ref1[i];
                results.push(data = expr.apply(data));
              }
              return results;
            }
          });
        }
      },
      transform: function(data) {
        return data;
      }
    }),
    new Extension('base',
    {
      argument: 'name',
      resolve: function() {
        var ref;
        ref = this.state.identity = this.lookup('identity',
    this.tag);
        if (ref == null) {
          throw this.error(`unable to resolve '${this.tag}' identity`);
        }
      }
    }),
    new Extension('belongs-to',
    {
      argument: 'module-name',
      scope: {
        prefix: '1'
      },
      resolve: function() {
        this.module = this.lookup('module',
    this.tag);
        if (this.module == null) {
          throw this.error(`unable to resolve '${this.tag}' module`);
        }
      }
    }),
    new Extension('bit',
    {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n', // YANG 1.1
        reference: '0..1',
        status: '0..1',
        position: '0..1'
      },
      resolve: function() {
        var base,
    cval;
        if ((base = this.parent).bitPosition == null) {
          base.bitPosition = 0;
        }
        if (this.position == null) {
          return this.extends(this.constructor.parse(`position ${this.parent.bitPosition++};`));
        } else {
          cval = (Number(this.position.tag)) + 1;
          if (!(this.parent.bitPosition > cval)) {
            return this.parent.bitPosition = cval;
          }
        }
      }
    }),
    new Extension('case',
    {
      argument: 'name',
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        reference: '0..1',
        status: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      resolve: function() {
        return this.once('compiled',
    () => {
          if (!(this.nodes.length > 0)) {
            throw this.error("cannot have an empty case statement");
          }
        });
      },
      transform: function(data,
    ctx,
    opts) {
        var expr,
    i,
    keys,
    len,
    ref1;
        if (!(data instanceof Object)) {
          return data;
        }
        keys = Object.keys(data);
        if (!(this.nodes.some(function(x) {
          var ref1;
          return ref1 = x.tag,
    indexOf.call(keys,
    ref1) >= 0;
        }))) {
          return data;
        }
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          data = expr.eval(data,
    ctx,
    opts);
        }
        return data;
      },
      predicate: function(data) {
        assert(data instanceof Object,
    "data must contain Object data");
        return assert(this.nodes.some(function(x) {
          return x.tag in data;
        }),
    "data must contain a matching element");
      }
    }),
    new Extension('choice',
    {
      argument: 'condition',
      data: true,
      scope: {
        anyxml: '0..n',
        case: '0..n',
        config: '0..1',
        container: '0..n',
        default: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        mandatory: '0..1',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var ref1;
        if ((this.case != null) && this.nodes.length) {
          throw this.error("cannot contain short-hand non-case data node statement when using case statements");
        }
        if (this.nodes.length) {
          this.extends(this.nodes.map((node) => {
            return (new Yang('case',
    node.tag)).extends(node);
          }));
          this.removes(this.nodes);
        }
        if (((ref1 = this.mandatory) != null ? ref1.tag : void 0) === 'true' && (this.default != null)) {
          throw this.error("cannot define 'default' when 'mandatory' is true");
        }
        if ((this.default != null) && ((this.match('case', this.default.tag)) == null)) {
          throw this.error(`cannot specify default '${this.default.tag}' without a corresponding case`);
        }
      },
      // TODO: need to ensure each nodes in case are unique
      transform: function(data,
    ctx,
    opts) {
        var attr,
    block,
    defcase,
    expr,
    i,
    j,
    l,
    len,
    len1,
    len2,
    len3,
    m,
    match,
    ref1,
    ref2,
    ref3,
    ref4;
        if (this.case == null) {
          ref1 = this.exprs;
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            data = expr.eval(data,
    ctx,
    opts);
          }
          return data;
        }
        ref2 = this.case;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          block = ref2[j];
          this.debug(() => {
            return `checking if case ${block.tag}...`;
          });
          try {
            data = block.eval(data,
    ctx,
    opts);
            match = block.tag;
            break;
          } catch (error) {}
        }
        switch (false) {
          case !((match == null) && (this.default != null)):
            this.debug(() => {
              return `choice fallback to default: ${this.default.tag}`;
            });
            match = this.default.tag;
            defcase = this.match('case',
    this.default.tag);
            ref3 = defcase.exprs;
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              expr = ref3[l];
              data = expr.eval(data,
    ctx,
    opts);
            }
            break;
          case !((match == null) && (this.mandatory != null)):
            throw this.error("no matching choice found (mandatory)");
        }
        ref4 = this.attrs;
        for (m = 0, len3 = ref4.length; m < len3; m++) {
          attr = ref4[m];
          if (attr.kind !== 'case') {
            data = attr.eval(data,
    ctx,
    opts);
          }
        }
        // TODO: need to address multiple choices in the data object
        Object.defineProperty(data,
    '@choice',
    {
          value: match
        });
        return data;
      },
      construct: function() {
        return this.apply(...arguments); // considered to be a 'node'
      }
    }),
    new Extension('config',
    {
      argument: 'value',
      resolve: function() {
        this.tag = this.tag === true || this.tag === 'true';
        return this.parent.once('compiled',
    () => {
          return this.parent.nodes.map((node) => {
            try {
              return node.update(this);
            } catch (error) {}
          });
        });
      }
    }),
    new Extension('contact',
    {
      argument: 'text',
      yin: true
    }),
    new Extension('container',
    {
      argument: 'name',
      data: true,
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        config: '0..1',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        must: '0..n',
        notification: '0..n',
        presence: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n',
        when: '0..1'
      },
      predicate: function(data = {}) {
        return assert(typeof data === 'object',
    "data must contain instance of Object");
      },
      construct: function() {
        return (new Container(this)).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var expr,
    i,
    k,
    kind,
    len,
    match,
    matches,
    parents,
    possibilities,
    ref1,
    v;
        if (!(data === Object(data) && !Array.isArray(data))) {
          return;
        }
        // return unless typeof data is 'object' and Object.keys(data).length > 0
        // return if data instanceof Array
        possibilities = (function() {
          var ref1,
    results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension',
    kind));
          }
          return results;
        }).call(this);
        matches = [];
        parents = (ref1 = opts.parents) != null ? ref1 : [];
        parents.push(data);
        for (k in data) {
          if (!hasProp.call(data, k)) continue;
          try {
            v = data[k];
          } catch (error) {
            continue;
          }
          if (indexOf.call(parents,
    v) >= 0) {
            this.debug(() => {
              return `found circular entry for '${k}'`;
            });
            matches.push(new Yang('anydata',
    k,
    this));
            continue;
          }
          for (i = 0, len = possibilities.length; i < len; i++) {
            expr = possibilities[i];
            if (!((expr != null ? expr.compose : void 0) != null)) {
              continue;
            }
            this.debug(() => {
              return `checking '${k}' to see if ${expr.tag}`;
            });
            match = expr.compose(v,
    {
              tag: k,
              parents: parents
            });
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            return;
          }
          matches.push(match);
        }
        parents.pop();
        return (new Yang(this.tag,
    opts.tag,
    this)).extends(...matches);
      }
    }),
    new Extension('default',
    {
      argument: 'value',
      transform: function(data) {
        return data != null ? data : this.tag;
      }
    }),
    new Extension('description',
    {
      argument: 'text',
      yin: true
    }),
    // TODO
    new Extension('deviate',
    {
      argument: 'value',
      scope: {
        config: '0..1',
        default: '0..1',
        mandatory: '0..1',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        type: '0..1',
        unique: '0..1',
        units: '0..1'
      }
    }),
    // TODO
    new Extension('deviation',
    {
      argument: 'target-node',
      scope: {
        description: '0..1',
        deviate: '1..n',
        reference: '0..1'
      }
    }),
    new Extension('enum',
    {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n', // YANG 1.1
        reference: '0..1',
        status: '0..1',
        value: '0..1'
      },
      resolve: function() {
        var base,
    cval;
        if ((base = this.parent).enumValue == null) {
          base.enumValue = 0;
        }
        if (this.value == null) {
          return this.extends(this.constructor.parse(`value ${this.parent.enumValue++};`));
        } else {
          cval = (Number(this.value.tag)) + 1;
          if (!(this.parent.enumValue > cval)) {
            return this.parent.enumValue = cval;
          }
        }
      }
    }),
    new Extension('error-app-tag',
    {
      argument: 'value'
    }),
    new Extension('error-message',
    {
      argument: 'value',
      yin: true
    }),
    new Extension('extension',
    {
      argument: 'extension-name',
      scope: {
        argument: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      resolve: function() {
        if (this.kind !== 'extension') {
          if (this.argument === 'extension-name') {
            // NOTE: we can't do a simple 'delete this.argument' since we
            // used delegates to bind getter/setter to the instance
            // prototype
            this.argument = false;
          }
        }
        this.debug(() => {
          return 'setting state of new extension unbound';
        });
        this.state.unbound = true;
        return this.once('bind',
    () => {
          var ext,
    key,
    name,
    opts,
    prefix,
    ref1,
    ref2,
    ref3,
    value;
          prefix = this.lookup('prefix');
          name = `${prefix}:${this.tag}`;
          this.debug(() => {
            return `registering new bound extension '${name}'`;
          });
          opts = this.binding;
          if (opts.argument == null) {
            opts.argument = (ref1 = this.argument) != null ? ref1.valueOf() : void 0;
          }
          this.source = new Extension(`${name}`,
    opts);
          if (opts.global === true) {
            this.constructor.scope[name] = '0..n';
          }
          ref3 = (ref2 = opts.target) != null ? ref2 : {};
          for (key in ref3) {
            value = ref3[key];
            ext = this.lookup('extension',
    key);
            if (ext != null) {
              ext.scope[name] = value;
            }
          }
          this.constructor.use(this.source);
          this.state.unbound = false;
          return this.emit('bound');
        });
      }
    }),
    new Extension('feature',
    {
      argument: 'name',
      scope: {
        description: '0..1',
        'if-feature': '0..n',
        reference: '0..1',
        status: '0..1'
      }
    }),
    // transform: (data, ctx) ->
    //   feature = @binding
    //   feature = expr.eval feature, ctx for expr in @exprs when feature?
    //   (new Property @tag, this).attach(ctx.instance) if ctx?.instance? and feature?
    //   return data
    new Extension('fraction-digits',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = Number(this.tag);
      }
    }),
    new Extension('grouping',
    {
      argument: 'name',
      scope: {
        action: '0..n',
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data,
    ctx) {
        var expr,
    i,
    len,
    prop,
    ref1;
        if (ctx == null) {
          this.debug(() => {
            return `applying grouping schema ${this.tag} directly`;
          });
          prop = (new Container({
            name: this.tag,
            schema: this
          })).set(data,
    {
            preserve: true
          });
          data = prop.data; // applied directly
        }
        if ((ctx != null ? ctx.schema : void 0) === this) {
          ref1 = this.exprs;
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            if (data != null) {
              data = expr.eval(data,
    ctx);
            }
          }
        }
        return data;
      }
    }),
    new Extension('identity',
    {
      argument: 'name',
      scope: {
        base: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      // TODO: resolve 'base' statements
      resolve: function() {
        if (this.base != null) {
          return this.lookup('identity',
    this.base.tag);
        }
      }
    }),
    new Extension('if-feature',
    {
      argument: 'if-feature-expr',
      resolve: function() {
        var expr,
    name1,
    ref1,
    target,
    test;
        expr = typeof Arguments[name1 = this.argument] === "function" ? Arguments[name1](this.tag) : void 0;
        test = (kw) => {
          var ref1;
          return ((ref1 = this.lookup('feature', kw)) != null ? ref1.binding : void 0) != null;
        };
        target = this.parent;
        return target != null ? (ref1 = target.parent) != null ? ref1.on('transforming',
    () => {
          if (!(typeof expr === "function" ? expr(test) : void 0)) {
            this.debug(() => {
              return `removed ${target.kind}:${target.tag} due to missing feature(s): ${this.tag}`;
            });
            return target.parent.remove(target);
          }
        }) : void 0 : void 0;
      }
    }),
    new Extension('import',
    {
      argument: 'module',
      scope: {
        prefix: '1',
        'revision-date': '0..1',
        description: '0..1', // YANG 1.1
        reference: '0..1' // YANG 1.1
      },
      resolve: function() {
        var module,
    ref1,
    rev;
        module = this.lookup('module',
    this.tag);
        if (module == null) {
          throw this.error(`unable to resolve '${this.tag}' module`);
        }
        // defined as non-enumerable
        Object.defineProperty(this,
    'module',
    {
          configurable: true,
          value: module
        });
        rev = (ref1 = this['revision-date']) != null ? ref1.tag : void 0;
        if ((rev != null) && ((this.module.match('revision', rev)) == null)) {
          throw this.error(`requested ${rev} not available in ${this.tag}`);
        }
      },
      transform: function(data,
    ctx) {
        // below is a very special transform
        if (this.module.nodes.length && Object.isExtensible(data) && ((ctx != null ? ctx.store : void 0) != null)) {
          if (!ctx.store.has(this.module.tag)) {
            this.debug(() => {
              return `IMPORT: absorbing data for '${this.tag}'`;
            });
            this.module.eval(data,
    ctx);
          }
        }
        // XXX - we probably don't need to do this...
        // @module.nodes.forEach (x) -> delete data[x.datakey]
        return data;
      }
    }),
    new Extension('include',
    {
      argument: 'module',
      scope: {
        'revision-date': '0..1',
        description: '0..1', // YANG 1.1
        reference: '0..1' // YANG 1.1
      },
      resolve: function() {
        var i,
    len,
    mod,
    ref1,
    sub,
    x;
        sub = this.lookup('submodule',
    this.tag);
        if (sub == null) {
          throw this.error(`unable to resolve '${this.tag}' submodule`);
        }
        mod = (function() {
          switch (this.root.kind) {
            case 'module':
              return this.root;
            case 'submodule':
              return this.root['belongs-to'].module;
          }
        }).call(this);
        if (mod.tag !== sub['belongs-to'].tag) {
          throw this.error(`requested submodule '${this.tag}' not belongs-to '${mod.tag}'`);
        }
        // defined as non-enumerable
        Object.defineProperty(sub['belongs-to'],
    'module',
    {
          configurable: true,
          value: mod
        });
        ref1 = sub.compile().children;
        for (i = 0, len = ref1.length; i < len; i++) {
          x = ref1[i];
          if (sub.scope[x.kind] === '0..n' && x.kind !== 'revision') {
            //@debug => "updating parent with #{x.kind}(#{x.tag})"
            this.parent.update(x);
          }
        }
        return sub.parent = this;
      }
    }),
    new Extension('input',
    {
      data: true,
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        must: '0..n', // RFC 7950
        typedef: '0..n',
        uses: '0..n'
      },
      //resolve: -> @tag = null if !@tag
      transform: function(data,
    ctx) {
        var expr,
    i,
    len,
    ref1;
        if (typeof data !== 'object') {
          return;
        }
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (data != null) {
            data = expr.eval(data,
    ctx);
          }
        }
        return data;
      },
      construct: function() {
        return (new Container(this)).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var ref1,
    res,
    str;
        if (!(data instanceof Function)) {
          return;
        }
        str = data.toString().replace(STRIP_COMMENTS,
    '');
        res = (ref1 = str.slice(str.indexOf('(') + 1, str.indexOf(')')).match(ARGUMENT_NAMES)) != null ? ref1 : [];
        if (data.length !== res.length) {
          this.debug(() => {
            return `argument length mismatch: expected ${data.length} but got ${res.length}`;
          });
        }
        return (new Yang(this.tag,
    null,
    this)).extends(res.map(function(x) {
          return Yang(`anydata ${x};`);
        }));
      }
    }),
    new Extension('key',
    {
      argument: 'value',
      resolve: function() {
        return this.parent.once('compiled',
    () => {
          this.tag = this.tag.split(' ');
          if (!(this.tag.every((k) => {
            return this.parent.match('leaf', k) != null;
          }))) {
            throw this.error("unable to reference key items as leaf elements",
    this.parent);
          }
        });
      },
      predicate: function(data) {
        if (!(data instanceof Object)) {
          return;
        }
        if (data instanceof Array) {
          return;
        }
        return assert(this.tag.every(function(k) {
          return data.hasOwnProperty(k);
        }),
    "data must contain values for all key leafs");
      },
      transform: function(data,
    ctx) {
        var exists;
        if (!(data instanceof Object)) {
          return data;
        }
        switch (false) {
          case !Array.isArray(data):
            exists = {};
            data.forEach((item) => {
              var key;
              if (typeof item !== 'object') {
                return;
              }
              key = item['@key'];
              if (exists[key]) {
                this.debug(() => {
                  return `found key conflict for ${key} inside ${this.parent.tag}`;
                });
                throw this.error(`key conflict for ${key}`,
    item);
              }
              return exists[key] = true;
            });
            break;
          case !!data.hasOwnProperty('@key'):
            Object.defineProperty(data,
    '@key',
    {
              get: (function() {
                return (this.tag.map(function(k) {
                  return data[k];
                })).join(',');
              }).bind(this)
            });
        }
        //ctx.state.key = data['@key'] if ctx?.state?
        return data;
      }
    }),
    new Extension('leaf',
    {
      argument: 'name',
      data: true,
      scope: {
        config: '0..1',
        default: '0..1',
        description: '0..1',
        'if-feature': '0..n',
        mandatory: '0..1',
        must: '0..n',
        reference: '0..1',
        status: '0..1',
        type: '0..1',
        units: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var ref1;
        if (((ref1 = this.mandatory) != null ? ref1.tag : void 0) === 'true' && (this.default != null)) {
          throw this.error("cannot define 'default' when 'mandatory' is true");
        }
      },
      predicate: function(data) {
        if (data instanceof Error) {
          return;
        }
        if (data instanceof Array) {
          return assert(data.length === 1 && data[0] === null,
    "data cannot be an Array");
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var expr,
    i,
    len,
    ref1;
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (expr.kind !== 'type') {
            data = expr.eval(data,
    ctx,
    opts);
          }
        }
        if (this.type != null) {
          data = this.type.apply(data,
    ctx,
    opts);
        }
        return data;
      },
      construct: function() {
        return (new Property(this)).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var ref1,
    type;
        if (data instanceof Array) {
          return;
        }
        if (data instanceof Object && Object.keys(data).length > 0) {
          return;
        }
        type = (ref1 = this.lookup('extension', 'type')) != null ? typeof ref1.compose === "function" ? ref1.compose(data) : void 0 : void 0;
        if (type == null) {
          return;
        }
        this.debug(() => {
          return `detected '${opts.tag}' as ${type != null ? type.tag : void 0}`;
        });
        return (new Yang(this.tag,
    opts.tag,
    this)).extends(type);
      }
    }),
    new Extension('leaf-list',
    {
      argument: 'name',
      data: true,
      scope: {
        config: '0..1',
        default: '0..n', // RFC 7950
        description: '0..1',
        'if-feature': '0..n',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        'ordered-by': '0..1',
        reference: '0..1',
        status: '0..1',
        type: '0..1',
        units: '0..1',
        when: '0..1'
      },
      predicate: function(data,
    opts = {}) {
        if ((data != null) && opts.strict) {
          return assert(data instanceof Array,
    "data must contain an Array");
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var expr,
    i,
    len,
    ref1,
    ref2;
        if (data == null) {
          data = (ref1 = this.default) != null ? ref1.keys : void 0;
        }
        if (typeof data === 'string') {
          data = data.split(/\s*,\s*/);
        }
        if ((data != null) && !Array.isArray(data)) {
          data = [data];
        }
        if (data != null) {
          data = Array.from(new Set(data)).filter(function(x) {
            return x !== void 0 && x !== null;
          });
        }
        ref2 = this.exprs;
        for (i = 0, len = ref2.length; i < len; i++) {
          expr = ref2[i];
          if (expr.kind !== 'type') {
            data = expr.eval(data,
    ctx,
    opts);
          }
        }
        if (this.type != null) {
          data = this.type.apply(data,
    ctx,
    opts);
        }
        return data;
      },
      construct: function() {
        return (new Property(this)).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var i,
    item,
    len,
    res,
    type_,
    types;
        if (!(data instanceof Array)) {
          return;
        }
        type_ = this.lookup('extension',
    'type');
        types = [];
        for (i = 0, len = data.length; i < len; i++) {
          item = data[i];
          res = typeof type_.compose === "function" ? type_.compose(item) : void 0;
          if (res == null) {
            return;
          }
          types.push(res);
        }
        // return unless data.every (x) -> typeof x isnt 'object'
        // types = data.map (x) -> type_.compose? x
        // TODO: form a type union if more than one types
        return (new Yang(this.tag,
    opts.tag,
    this)).extends(types[0]);
      }
    }),
    new Extension('length',
    {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }),
    new Extension('list',
    {
      argument: 'name',
      data: true,
      scope: {
        action: '0..n', // v1.1
        anydata: '0..n', // v1.1
        anyxml: '0..n',
        choice: '0..n',
        config: '0..1',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        key: '0..1',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        'max-elements': '0..1',
        'min-elements': '0..1',
        must: '0..n',
        notification: '0..n',
        'ordered-by': '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        unique: '0..1',
        uses: '0..n',
        when: '0..1'
      },
      predicate: function(data = {}) {
        return assert(data instanceof Object,
    "data must be an Object");
      },
      transform: function(data,
    ctx,
    opts) {
        var attr,
    i,
    j,
    len,
    len1,
    node,
    ref1,
    ref2;
        if (data == null) {
          return;
        }
        if (Array.isArray(data)) {
          data = data.map((item) => {
            return (new List.Item(this)).attach(item,
    ctx,
    opts);
          });
        } else {
          ref1 = this.nodes;
          for (i = 0, len = ref1.length; i < len; i++) {
            node = ref1[i];
            if (data != null) {
              data = node.eval(data,
    ctx,
    opts);
            }
          }
        }
        ref2 = this.attrs;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          attr = ref2[j];
          if (data != null) {
            data = attr.eval(data,
    ctx,
    opts);
          }
        }
        return data;
      },
      construct: function() {
        return (new List(this)).attach(...arguments);
      },
      compose: function(data,
    opts = {}) {
        var expr,
    i,
    k,
    kind,
    len,
    match,
    matches,
    parents,
    possibilities,
    ref1,
    v;
        if (!(data instanceof Array && data.length > 0)) {
          return;
        }
        if (!data.every(function(x) {
          return typeof x === 'object';
        })) {
          return;
        }
        // TODO: inspect more than first element
        data = data[0];
        possibilities = (function() {
          var ref1,
    results;
          ref1 = this.scope;
          results = [];
          for (kind in ref1) {
            if (!hasProp.call(ref1, kind)) continue;
            results.push(this.lookup('extension',
    kind));
          }
          return results;
        }).call(this);
        matches = [];
        parents = (ref1 = opts.parents) != null ? ref1 : [];
        parents.push(data);
        for (k in data) {
          if (!hasProp.call(data, k)) continue;
          v = data[k];
          if (indexOf.call(parents,
    v) >= 0) {
            this.debug(() => {
              return `found circular entry for '${k}'`;
            });
            matches.push(new Yang('anydata',
    k,
    this));
            continue;
          }
          for (i = 0, len = possibilities.length; i < len; i++) {
            expr = possibilities[i];
            if (!(expr != null)) {
              continue;
            }
            match = typeof expr.compose === "function" ? expr.compose(v,
    {
              tag: k,
              parents: parents
            }) : void 0;
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            return;
          }
          matches.push(match);
        }
        parents.pop();
        return (new Yang(this.tag,
    opts.tag,
    this)).extends(...matches);
      }
    }),
    new Extension('mandatory',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === true || this.tag === 'true';
      },
      predicate: function(data) {
        return assert(this.tag !== true || (data != null) || (this.parent.binding != null),
    "data must be defined");
      }
    }),
    new Extension('max-elements',
    {
      argument: 'value',
      resolve: function() {
        if (this.tag !== 'unbounded') {
          return this.tag = Number(this.tag);
        }
      },
      predicate: function(data) {
        return assert(this.tag === 'unbounded' || !(data instanceof Array) || data.length <= this.tag,
    `data must contain less than maximum entries (${this.tag})`);
      }
    }),
    new Extension('min-elements',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = Number(this.tag);
      },
      predicate: function(data) {
        return assert(!(data instanceof Array) || data.length >= this.tag,
    `data must contain more than minimum entries (${this.tag})`);
      }
    }),
    // TODO
    new Extension('modifier',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === 'invert-match';
      }
    }),
    new Extension('module',
    {
      argument: 'name',
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        augment: '0..n',
        choice: '0..n',
        contact: '0..1',
        container: '0..n',
        description: '0..1',
        deviation: '0..n',
        extension: '0..n',
        feature: '0..n',
        grouping: '0..n',
        identity: '0..n',
        import: '0..n',
        include: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        namespace: '0..1',
        notification: '0..n',
        organization: '0..1',
        prefix: '0..1',
        reference: '0..1',
        revision: '0..n',
        rpc: '0..n',
        typedef: '0..n',
        uses: '0..n',
        'yang-version': '0..1'
      },
      resolve: function() {
        var ref1,
    ref2;
        if (((ref1 = this['yang-version']) != null ? ref1.tag : void 0) === '1.1') {
          if (!((this.namespace != null) && (this.prefix != null))) {
            throw this.error("must define 'namespace' and 'prefix' for YANG 1.1 compliance");
          }
        }
        if (((ref2 = this.extension) != null ? ref2.length : void 0) > 0) {
          return this.debug(() => {
            return `found ${this.extension.length} new extension(s)`;
          });
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var expr,
    i,
    len,
    ref1;
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if ((data != null) && expr.kind !== 'extension') {
            data = expr.eval(data,
    ctx,
    opts);
          }
        }
        return data;
      },
      construct: function() {
        return (new Model({
          name: this.tag,
          schema: this
        })).attach(...arguments);
      }
    }),
    // TODO
    new Extension('must',
    {
      argument: 'condition',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }),
    new Extension('namespace',
    {
      argument: 'value'
    }),
    new Extension('notification',
    {
      argument: 'event',
      data: true,
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        must: '0..n', // RFC 7950
        reference: '0..1',
        status: '0..1',
        typedef: '0..n',
        uses: '0..n'
      },
      construct: function() {
        return (new Notification(this)).attach(...arguments);
      }
    }),
    new Extension('ordered-by',
    {
      argument: 'value'
    }),
    new Extension('organization',
    {
      argument: 'text',
      yin: true
    }),
    new Extension('output',
    {
      data: true,
      scope: {
        anydata: '0..n',
        anyxml: '0..n',
        choice: '0..n',
        container: '0..n',
        grouping: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        must: '0..n', // RFC 7950
        typedef: '0..n',
        uses: '0..n'
      },
      transform: function(data,
    ctx) {
        var expr,
    i,
    len,
    ref1;
        if (data instanceof Promise) {
          return data;
        }
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (data != null) {
            data = expr.eval(data,
    ctx);
          }
        }
        return data;
      },
      construct: function() {
        return (new Container(this)).attach(...arguments);
      }
    }),
    new Extension('path',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = this.normalizePath(this.tag);
      }
    }),
    new Extension('pattern',
    {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        modifier: '0..1',
        reference: '0..1'
      },
      resolve: function() {
        return this.tag = new RegExp(`^(?:${this.tag})$`);
      }
    }),
    new Extension('position',
    {
      argument: 'value'
    }),
    new Extension('prefix',
    {
      argument: 'value',
      resolve: function() {} // should validate prefix naming convention
    }),
    new Extension('presence',
    {
      argument: 'value'
    }),
    new Extension('range',
    {
      argument: 'value',
      scope: {
        description: '0..1',
        'error-app-tag': '0..1',
        'error-message': '0..1',
        reference: '0..1'
      }
    }),
    new Extension('reference',
    {
      argument: 'value'
    }),
    new Extension('refine',
    {
      argument: 'target-node',
      scope: {
        default: '0..1',
        description: '0..1',
        reference: '0..1',
        config: '0..1',
        'if-feature': '0..n', // YANG 1.1
        mandatory: '0..1',
        presence: '0..1',
        must: '0..n',
        'min-elements': '0..1',
        'max-elements': '0..1',
        units: '0..1'
      },
      resolve: function() {
        var target;
        target = this.parent.state.grouping.locate(this.tag);
        if (target == null) {
          console.warn(this.error(`unable to locate '${this.tag}'`));
          return;
        }
        this.debug(() => {
          return `APPLY ${this} to ${target}`;
        });
        // TODO: revisit this logic, may need to 'merge' the new expr into existing expr
        return this.exprs.forEach(function(expr) {
          var ref1;
          switch (false) {
            case !target.hasOwnProperty(expr.kind):
              if ((ref1 = expr.kind) === 'must' || ref1 === 'if-feature') {
                return target.extends(expr);
              } else {
                return target.merge(expr,
    {
                  replace: true
                });
              }
              break;
            default:
              return target.extends(expr);
          }
        });
      }
    }),
    new Extension('require-instance',
    {
      argument: 'value',
      resolve: function() {
        return this.tag = this.tag === true || this.tag === 'true';
      }
    }),
    new Extension('revision',
    {
      argument: 'date',
      scope: {
        description: '0..1',
        reference: '0..1',
        status: '0..1' // deviation from RFC 6020
      }
    }),
    new Extension('revision-date',
    {
      argument: 'date'
    }),
    new Extension('rpc',
    {
      argument: 'name',
      scope: {
        description: '0..1',
        grouping: '0..n',
        'if-feature': '0..n',
        input: '0..1',
        output: '0..1',
        reference: '0..1',
        status: '0..1',
        typedef: '0..n'
      },
      predicate: function(data = function() {}) {
        return assert(data instanceof Function,
    "data must be a Function");
      },
      resolve: function() {
        if (!this.input) {
          this.extends(new Yang('input'));
        }
        if (!this.output) {
          return this.extends(new Yang('output'));
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var attr,
    i,
    len,
    ref1;
        if (data == null) {
          return;
        }
        if (!(data instanceof Function)) {
          this.debug(() => {
            return data;
          });
          // TODO: allow data to be a 'string' compiled into a Function?
          throw this.error(`expected a function but got a '${typeof data}'`);
        }
        ref1 = this.attrs;
        for (i = 0, len = ref1.length; i < len; i++) {
          attr = ref1[i];
          data = attr.eval(data,
    ctx,
    opts);
        }
        return data;
      },
      construct: function() {
        return (new Method(this)).attach(...arguments);
      }
    }),
    new Extension('status',
    {
      argument: 'value',
      resolve: function() {
        var ref1;
        return this.tag = (ref1 = this.tag) != null ? ref1 : 'current';
      }
    }),
    new Extension('submodule',
    {
      argument: 'name',
      scope: {
        anyxml: '0..n',
        augment: '0..n',
        'belongs-to': '0..1',
        choice: '0..n',
        contact: '0..1',
        container: '0..n',
        description: '0..1',
        deviation: '0..n',
        extension: '0..n',
        feature: '0..n',
        grouping: '0..n',
        identity: '0..n',
        import: '0..n',
        include: '0..n',
        leaf: '0..n',
        'leaf-list': '0..n',
        list: '0..n',
        notification: '0..n',
        organization: '0..1',
        reference: '0..1',
        revision: '0..n',
        rpc: '0..n',
        typedef: '0..n',
        uses: '0..n',
        'yang-version': '0..1'
      }
    }),
    new Extension('type',
    {
      argument: 'name',
      scope: {
        base: '0..1',
        bit: '0..n',
        enum: '0..n',
        'fraction-digits': '0..1',
        length: '0..1',
        path: '0..1',
        pattern: '0..n',
        range: '0..1',
        'require-instance': '0..1',
        type: '0..n' // for 'union' case only
      },
      resolve: function() {
        var convert,
    ref1,
    typedef;
        if ((this.type != null) && this.tag !== 'union') {
          throw this.error("cannot have additional type definitions unless 'union'");
        }
        typedef = this.lookup('typedef',
    this.tag);
        if (typedef == null) {
          this.debug(() => {
            return this.parent;
          });
          throw this.error(`unable to resolve typedef for ${this.tag}`);
        }
        if (typedef.type != null) {
          this.once('compiled',
    () => {
            var expr,
    i,
    len,
    ref1,
    results;
            ref1 = typedef.type.exprs;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              expr = ref1[i];
              try {
                results.push(this.merge(expr));
              } catch (error) {}
            }
            return results;
          });
        }
        convert = typedef.convert;
        if (convert == null) {
          convert = typedef.compile().convert;
        }
        if (convert == null) {
          throw this.error(`no convert found for ${typedef.tag}`);
        }
        this.state.basetype = (ref1 = typedef.basetype) != null ? ref1 : typedef.state.basetype;
        this.convert = convert.bind(this);
        if ((this.parent != null) && this.parent.kind !== 'type') {
          try {
            return this.parent.extends(typedef.default,
    typedef.units);
          } catch (error) {}
        }
      },
      transform: function(data,
    ctx,
    opts) {
        var res;
        if (!(data !== void 0 && (data instanceof Array || !(data instanceof Object)))) {
          return data;
        }
        if (data instanceof Array) {
          res = data.map((x) => {
            return this.convert(x,
    ctx,
    opts);
          });
          if (!ctx.attached && res.some(function(x) {
            return x instanceof Error;
          })) {
            ctx.defer(data);
          }
        } else {
          res = this.convert(data,
    ctx,
    opts);
          if (!ctx.attached && res instanceof Error) {
            ctx.defer(data);
          }
        }
        return res;
      },
      compose: function(data,
    opts = {}) {
        var e,
    i,
    len,
    ref1,
    typedef,
    typedefs;
        if (data instanceof Function) {
          return;
        }
        //return if data instanceof Object and Object.keys(data).length > 0
        typedefs = this.lookup('typedef');
        ref1 = typedefs.concat({
          tag: 'unknown'
        });
        for (i = 0, len = ref1.length; i < len; i++) {
          typedef = ref1[i];
          this.debug(() => {
            return `checking if ${typedef.tag}`;
          });
          try {
            if ((typedef.convert(data)) !== void 0) {
              break;
            }
          } catch (error) {
            e = error;
            this.debug(() => {
              return e.message;
            });
          }
        }
        if (typedef.tag === 'unknown') {
          return;
        }
        return new Yang(this.tag,
    typedef.tag);
      }
    }),
    // TODO: address deviation from the conventional pattern
    new Extension('typedef',
    {
      argument: 'name',
      scope: {
        default: '0..1',
        description: '0..1',
        units: '0..1',
        type: '0..1',
        reference: '0..1',
        status: '0..1'
      },
      resolve: function() {
        var builtin;
        if (this.type != null) {
          this.convert = this.type.compile().convert;
          this.state.basetype = this.type.state.basetype;
          return;
        }
        builtin = this.lookup('typedef',
    this.tag);
        if (builtin == null) {
          throw this.error(`unable to resolve '${this.tag}' built-in type`);
        }
        this.state.basetype = builtin.basetype;
        return this.convert = builtin.convert;
      }
    }),
    new Extension('unique',
    {
      argument: 'tag',
      resolve: function() {
        return this.parent.once('compiled',
    () => {
          this.tag = this.tag.split(' ');
          if (!(this.tag.every((k) => {
            var ref1;
            return ((ref1 = this.parent.locate(k)) != null ? ref1.kind : void 0) === 'leaf';
          }))) {
            throw this.error("referenced unique items do not have leaf elements");
          }
        });
      },
      predicate: function(data) {
        var isUnique,
    seen;
        if (!(data instanceof Array)) {
          return;
        }
        seen = {};
        isUnique = data.every((item) => {
          var key;
          if (!this.tag.every(function(k) {
            return item[k] != null;
          })) {
            return true;
          }
          key = this.tag.reduce((function(a,
    b) {
            return a += item[b];
          }),
    '');
          if (seen[key]) {
            return false;
          }
          seen[key] = true;
          return true;
        });
        return assert(isUnique,
    `data must contain unique entries of ${this.tag}`);
      }
    }),
    new Extension('units',
    {
      argument: 'value'
    }),
    new Extension('uses',
    {
      argument: 'grouping-name',
      scope: {
        augment: '0..n',
        description: '0..1',
        'if-feature': '0..n',
        refine: '0..n',
        reference: '0..1',
        status: '0..1',
        when: '0..1'
      },
      resolve: function() {
        var grouping,
    ref;
        grouping = this.lookup('grouping',
    this.tag);
        if (grouping == null) {
          throw this.error(`unable to resolve ${this.tag} grouping definition`);
        }
        // setup change linkage to upstream definition
        //grouping.on 'changed', => @emit 'changed'

        // NOTE: declared as non-enumerable
        //Object.defineProperty this, 'grouping', value: 
        if (this.when == null) {
          ref = this.state.grouping = grouping.clone().compile();
          this.debug(() => {
            return `extending with ${ref.nodes.length} elements`;
          });
          return this.parent.extends(ref.nodes);
        } else {
          return this.parent.on('transformed',
    (data) => {
            var expr,
    i,
    len,
    ref1,
    results;
            if (data != null) {
              ref1 = this.exprs;
              results = [];
              for (i = 0, len = ref1.length; i < len; i++) {
                expr = ref1[i];
                results.push(data = expr.apply(data));
              }
              return results;
            }
          });
        }
      },
      transform: function(data) {
        return data;
      }
    }),
    new Extension('value',
    {
      argument: 'value' // required
    }),
    
    // TODO
    new Extension('when',
    {
      argument: 'condition',
      scope: {
        description: '0..1',
        reference: '0..1'
      }
    }),
    new Extension('yang-version',
    {
      argument: 'value'
    }),
    new Extension('yin-element',
    {
      argument: 'value'
    })
  ];

}).call(this);
