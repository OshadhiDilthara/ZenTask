// Generated by CoffeeScript 2.5.1
(function() {
  var Integer, Typedef, generateRangeTest;

  ({Typedef} = require('..'));

  generateRangeTest = function(expr) {
    var max, min;
    [min, max] = expr.split(/\s*\.\.\s*/);
    min = Number(min);
    max = (function() {
      switch (false) {
        case max !== 'max':
          return null;
        default:
          return Number(max);
      }
    })();
    return function(v) {
      return ((min == null) || v >= min) && ((max == null) || v <= max);
    };
  };

  Integer = class Integer extends Typedef {
    constructor(name, range) {
      var source;
      source = {
        construct: function(value, ctx, opts = {}) {
          var ranges, ref, tests;
          if ((Number.isNaN(Number(value))) || ((Number(value)) % 1) !== 0) {
            throw ctx.error(`[${this.tag}] unable to convert '${value}'`);
          }
          // treat '' string as undefined
          if (typeof value === 'string' && value === '') {
            return;
          }
          if (opts.strict && typeof value !== number) {
            throw ctx.error(`[${this.tag}] must be a number but got ${typeof value}`);
          }
          value = Number(value);
          ranges = (ref = this.range) != null ? ref.tag.split('|') : void 0;
          if ((ranges != null) && ranges.length) {
            tests = ranges.map(generateRangeTest);
          }
          if (!((tests == null) || tests.some(function(test) {
            return typeof test === "function" ? test(value) : void 0;
          }))) {
            throw ctx.error(`[${this.tag}] custom range violation for '${value}' on ${ranges}`);
          }
          if (!generateRangeTest(range)(value)) {
            throw ctx.error(`[${this.tag}] range violation for '${value}' on ${range}`);
          }
          return value;
        }
      };
      super(name, source);
    }

  };

  module.exports = [
    new Typedef('bits',
    {
      construct: function(value,
    ctx) {
        var ref;
        if (!(((ref = this.bit) != null ? ref.length : void 0) > 0)) {
          throw ctx.error(`[${this.tag}] must have one or more 'bit' definitions`);
        }
        if (!((value != null) && typeof value === 'string')) {
          return;
        }
        // TODO: handle value a number in the future
        value = value.split(' ');
        if (!(value.every(function(v) {
          return this.bit.some(function(b) {
            return b.tag === v;
          });
        }))) {
          throw ctx.error(`[${this.tag}] invalid bit name(s) for '${value}' on ${this.bit.map(function(x) {
            return x.tag;
          })}`);
        }
        return value;
      }
    }),
    new Typedef('boolean',
    {
      construct: function(value,
    ctx) {
        switch (false) {
          case typeof value !== 'string':
            if (value !== 'true' && value !== 'false') {
              throw ctx.error(`[${this.tag}] ${value} must be 'true' or 'false'`);
            }
            return value === 'true';
          case typeof value !== 'boolean':
            return value;
          default:
            throw ctx.error(`[${this.tag}] unable to convert '${value}'`);
        }
      }
    }),
    new Typedef('empty',
    {
      construct: function(value,
    ctx) {
        this.debug(() => {
          return "convert";
        });
        this.debug(() => {
          return value;
        });
        if (value !== null) {
          throw ctx.error(`[${this.tag}] cannot contain value other than null`);
        }
        return null;
      }
    }),
    new Typedef('binary',
    {
      construct: function(value,
    ctx) {
        if (!(value instanceof Buffer)) {
          throw ctx.error(`[${this.tag}] unable to convert '${value}'`);
        }
        return value;
      }
    }),
    new Integer('int8',
    '-128..127'),
    new Integer('int16',
    '-32768..32767'),
    new Integer('int32',
    '-2147483648..2147483647'),
    new Integer('int64',
    '-9223372036854775808..9223372036854775807'),
    new Integer('uint8',
    '0..255'),
    new Integer('uint16',
    '0..65535'),
    new Integer('uint32',
    '0..4294967295'),
    new Integer('uint64',
    '0..18446744073709551615'),
    new Typedef('decimal64',
    {
      construct: function(value,
    ctx) {
        var a,
    b,
    fixed,
    ranges,
    ref,
    ref1,
    tests;
        if (Number.isNaN(Number(value))) {
          throw ctx.error(`[${this.tag}] unable to convert '${value}'`);
        }
        // treat '' string as undefined
        if (typeof value === 'string' && value === '') {
          return;
        }
        fixed = ((ref = this['fraction-digits']) != null ? ref.tag : void 0) || 1;
        [a,
    b] = value.toString().split('.');
        if ((b != null ? b.length : void 0) > fixed) {
          throw ctx.error(`[${this.tag}] fraction-digits violation for '${value}' with more than ${fixed} decimal precision`);
        }
        value = Number(Number(value).toFixed(fixed));
        ranges = (ref1 = this.range) != null ? ref1.tag.split('|') : void 0;
        if ((ranges != null) && ranges.length) {
          tests = ranges.map(generateRangeTest);
        }
        if (!((tests == null) || tests.some(function(test) {
          return typeof test === "function" ? test(value) : void 0;
        }))) {
          throw ctx.error(`[${this.tag}] custom range violation for '${value}' on ${ranges}`);
        }
        return value;
      }
    }),
    new Typedef('string',
    {
      construct: function(value,
    ctx,
    opts = {}) {
        var lengths,
    patterns,
    ref,
    ref1,
    tests,
    type;
        patterns = (ref = this.pattern) != null ? ref.map(function(x) {
          return x.tag;
        }) : void 0;
        lengths = (ref1 = this.length) != null ? ref1.tag.split('|') : void 0;
        tests = lengths != null ? lengths.map(function(e) {
          var max,
    min;
          [min,
    max] = e.split(/\s*\.\.\s*/);
          min = Number(min);
          max = (function() {
            switch (false) {
              case !(max == null):
                return min;
              case max !== 'max':
                return null;
              default:
                return Number(max);
            }
          })();
          return function(v) {
            return ((min == null) || v.length >= min) && ((max == null) || v.length <= max);
          };
        }) : void 0;
        if (value === null) {
          return;
        }
        type = typeof value;
        if (opts.strict && type !== 'string') {
          throw ctx.error(`[${this.tag}] must be a string but got ${type}`);
        }
        value = String(value);
        if (type === 'object' && /^\[object/.test(value)) {
          throw ctx.error(`[${this.tag}] unable to convert '${value}' into string`);
        }
        if (!((tests == null) || tests.some(function(test) {
          return typeof test === "function" ? test(value) : void 0;
        }))) {
          throw ctx.error(`[${this.tag}] length violation for '${value}' on ${lengths}`);
        }
        if (!((patterns == null) || patterns.every(function(regex) {
          return regex.test(value);
        }))) {
          throw ctx.error(`[${this.tag}] pattern violation for '${value}'`);
        }
        return value;
      }
    }),
    new Typedef('union',
    {
      construct: function(value,
    ctx) {
        var j,
    len,
    ref,
    type;
        if (this.type == null) {
          throw ctx.error(`[${this.tag}] must contain one or more type definitions`);
        }
        ref = this.type;
        for (j = 0, len = ref.length; j < len; j++) {
          type = ref[j];
          try {
            return type.convert(value);
          } catch (error) {
            continue;
          }
        }
        throw ctx.error(`[${this.tag}] unable to find matching type for '${value}' within: ${this.type}`);
      }
    }),
    new Typedef('enumeration',
    {
      construct: function(value,
    ctx) {
        var i,
    j,
    len,
    ref,
    ref1;
        if (!(((ref = this.enum) != null ? ref.length : void 0) > 0)) {
          throw ctx.error(`[${this.tag}] must have one or more 'enum' definitions`);
        }
        ref1 = this.enum;
        for (j = 0, len = ref1.length; j < len; j++) {
          i = ref1[j];
          if (value === i.tag) {
            return i.tag;
          }
          if (value === i.value.tag) {
            return i.tag;
          }
          if (`${value}` === i.value.tag) {
            return i.tag;
          }
        }
        throw ctx.error(`[${this.tag}] type violation for '${value}' on ${this.enum.map(function(x) {
          return x.tag;
        })}`);
      }
    }),
    // TODO
    new Typedef('identityref',
    {
      construct: function(value,
    ctx) {
        var dep,
    imports,
    j,
    k,
    len,
    len1,
    m,
    match,
    modules,
    ref;
        if (!((this.base != null) && typeof this.base.tag === 'string')) {
          throw ctx.error(`[${this.tag}] must reference 'base' identity`);
        }
        return value; // BYPASS FOR NOW
        match = this.lookup('identity',
    value);
        if (match == null) {
          imports = (ref = this.lookup('import')) != null ? ref : [];
          for (j = 0, len = imports.length; j < len; j++) {
            dep = imports[j];
            match = dep.module.lookup('identity',
    value);
            if (match != null) {
              break;
            }
          }
          if (match == null) {
            modules = this.lookup('module');
            this.debug(() => {
              return `fallback searching all modules ${modules.map(function(x) {
                return x.tag;
              })}`;
            });
            for (k = 0, len1 = modules.length; k < len1; k++) {
              m = modules[k];
              match = m.lookup('identity',
    value);
              if (match != null) {
                break;
              }
            }
          }
        }
        if ((match != null ? match.base : void 0) != null) {
          match = match.base.state.identity;
        }
        this.debug(() => {
          return `base: ${this.base} match: ${match} value: ${value}`;
        });
        // TODO - need to figure out how to return namespace value...
        if (!((match != null) && this.base.state.identity === match)) {
          throw ctx.error(`[${this.tag}] identityref is invalid for '${value}'`);
        }
        return value;
      }
    }),
    new Typedef('instance-identifier',
    {
      construct: function(value,
    ctx) {
        var e,
    err,
    prop,
    ref;
        this.debug(() => {
          return `processing instance-identifier with ${value}`;
        });
        try {
          prop = ctx.in(value);
          if (prop == null) {
            throw ctx.error("missing schema element, identifier is invalid");
          }
          if (((ref = this['require-instance']) != null ? ref.tag : void 0) && !prop.active) {
            throw ctx.error("missing instance data");
          }
        } catch (error) {
          e = error;
          err = new Error(`[${this.tag}] ${ctx.name} is invalid for '${value}' (not found in ${value})`);
          err['error-tag'] = 'data-missing';
          err['error-app-tag'] = 'instance-required';
          err['err-path'] = value;
          err.toString = function() {
            return value;
          };
          if (ctx.attached) {
            throw ctx.error(err);
          }
          return err;
        }
        return value;
      }
    }),
    new Typedef('leafref',
    {
      construct: function(value,
    ctx) {
        var err,
    ref,
    res,
    valid;
        if (this.path == null) {
          throw new Error(`[${this.tag}] must contain 'path' statement`);
        }
        if (((ref = this['require-instance']) != null ? ref.tag : void 0) === false) {
          return value;
        }
        this.debug(() => {
          return `processing leafref with ${this.path.tag}`;
        });
        res = ctx.get(this.path.tag);
        this.debug(() => {
          return `got back ${res}`;
        });
        valid = (function() {
          switch (false) {
            case !(res instanceof Array):
              return res.some(function(x) {
                return `${x}` === `${value}`;
              });
            default:
              return `${res}` === `${value}`;
          }
        })();
        if (valid !== true) {
          this.debug(() => {
            return `invalid leafref '${value}' detected for ${this.path.tag}`;
          });
          this.debug(() => {
            return ctx.state;
          });
          err = new Error(`[${this.tag}] ${ctx.name} is invalid for '${value}' (not found in ${this.path.tag})`);
          err['error-tag'] = 'data-missing';
          err['error-app-tag'] = 'instance-required';
          err['err-path'] = this.path.tag;
          err.toString = function() {
            return value;
          };
          if (ctx.attached) {
            throw ctx.error(err);
          }
          return err;
        }
        return value;
      }
    })
  ];

}).call(this);
