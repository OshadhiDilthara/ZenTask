// Generated by CoffeeScript 2.5.1
(function() {
  // # Property - controller of Object properties

  // The `Property` class is the *secretive shadowy* element that governs
  // `Object` behavior and are bound to the `Object` via
  // `Object.defineProperty`. It acts like a shadow `Proxy/Reflector` to
  // the `Object` instance and provides tight control via the
  // `Getter/Setter` interfaces.

  // Below are list of properties available to every instance of `Property`:

  // property | type | mapping | description
  // --- | --- | --- | ---
  // name   | string | direct | name of the property
  // schema | object | direct | a schema instance (usually [Yang](./src/yang.listcoffee))
  // state  | object | direct | *private* object holding internal state
  // configurable | boolean | getter(state) | defines whether this property can be redefined
  // enumerable   | boolean | getter(state) | defines whether this property is enumerable
  // content | any | computed | getter/setter for `state.value`
  // context | object | computed | dynamically generated using [context](./src/context.coffee)
  // root  | [Property](./src/property.litcoffee) | computed | dynamically returns the root Property instance
  // path  | [XPath](./src/xpath.coffee) | computed | dynamically generate XPath for this Property from root

  // ## Class Property
  var Property, XPath, Yang, context, debug, delegate;

  debug = require('debug');

  delegate = require('delegates');

  context = require('./context');

  Yang = require('./yang');

  XPath = require('./xpath');

  Property = (function() {
    class Property {
      static property(prop, desc) {
        return Object.defineProperty(this.prototype, prop, desc);
      }

      debug(f) {
        switch (false) {
          case !debug.enabled(this.logger.namespace):
            switch (false) {
              case typeof f !== 'function':
                return this.logger(this.uri, ...[].concat(f()));
              default:
                return this.logger(this.uri, ...arguments);
            }
        }
      }

      constructor(spec = {}) {
        var name, schema;
        if (typeof spec === 'string') {
          // NOTE: ES6/CS2 does not support below
          // unless this instanceof Property then return new Property arguments...

          // 1. parse if spec is YANG definition (string)
          spec = Yang.parse(spec);
        }
        if (spec instanceof Yang) {
          
          // 2. assign if spec is an instance of Yang schema
          schema = spec;
        }
        if (schema == null) {
          
            // 3. destructure spec as an object if not schema as instance
          ({name, schema} = spec);
        }
        if (typeof schema === 'string') {
          
          // 4. parse if schema is YANG definition (string)
          schema = Yang.parse(schema);
        }
        if (schema == null) {
          schema = {
            kind: 'anydata'
          };
        }
        // 5. initialize property instance
        this.name = name != null ? name : schema.datakey;
        this.schema = schema;
        this.state = {
          strict: false,
          private: false,
          mutable: schema.config != false,
          attached: false,
          replaced: false,
          changed: false,
          locked: false,
          prior: void 0,
          value: void 0,
          parent: null
        };
        // 6. soft freeze this instance
        Object.preventExtensions(this);
      }

      // ## Instance-level methods
      clone(state = {}) {
        var copy;
        if (typeof state !== 'object') {
          throw this.error('must clone with state typeof object');
        }
        copy = new this.constructor(this);
        copy.state = Object.assign(Object.create(this.state), state, {
          origin: this
        });
        return copy;
      }

      equals(a, b) {
        switch (this.kind) {
          case 'leaf-list':
            if (!(a && b)) {
              return false;
            }
            a = Array.from(new Set([].concat(a)));
            b = Array.from(new Set([].concat(b)));
            if (a.length !== b.length) {
              return false;
            }
            return a.every((x) => {
              return b.some((y) => {
                return x === y;
              });
            });
          default:
            return a === b;
        }
      }

      // ### get (key)

        // This is the main `Getter` for the target object's property value. When
      // called with optional `key` it will perform an internal
      // [find](#find-xpath) operation to traverse/locate that value being
      // requested instead of returning its own `@data`.

        // It also provides special handling based on different types of
      // `@data` currently held.
      get(key) {
        var match;
        switch (false) {
          case key == null:
            try {
              match = this.find(key);
            } catch (error) {}
            if (!((match != null) && match.length)) {
              return;
            }
            switch (false) {
              case match.length !== 1:
                return match[0].data;
              case !(match.length > 1):
                return match.map(function(x) {
                  return x.data;
                });
              default:
                return void 0;
            }
            break;
          default:
            return this.data;
        }
      }

      // ### set (value)

        // This is the main `Setter` for the target object's property value.  It
      // utilizes internal `@schema` attribute if available to enforce schema
      // validations.
      set(value, opts = {}) {
        var bypass, e, ref, ref1, subopts;
        if (opts.origin == null) {
          opts.origin = this;
        }
        
        // @debug => "[set] enter..."
        if (!(this.mutable || (value == null) || opts.force)) {
          throw this.error("cannot set data on read-only (config false) element", 'set');
        }
        try {
          if (((ref = this.binding) != null ? ref.set : void 0) != null) {
            value = this.binding.set(this.context.with(opts), value);
          }
        } catch (error) {
          e = error;
          throw this.error(e, 'set');
        }
        if ((value != null) && this.equals(value, this.value)) { // return if same value
          return this;
        }
        bypass = opts.bypass && ((ref1 = this.kind) === "leaf" || ref1 === "leaf-list");
        this.debug(() => {
          return "[set] applying schema...";
        });
        value = (function() {
          switch (false) {
            case !((this.schema.apply != null) && !bypass):
              subopts = Object.assign({}, opts, {
                inner: true
              });
              try {
                return this.schema.apply(value, this, subopts);
              } catch (error) {
                e = error;
                throw this.error(e, 'set');
              }
              break;
            default:
              return value;
          }
        }).call(this);
        this.debug(() => {
          return "[set] done applying schema...";
        });
        if (value instanceof Error) {
          return this;
        }
        if ((value != null) && this.equals(value, this.value)) { // return if same value
          return this;
        }
        this.debug(() => {
          return `[set] replaced? ${this.state.value != null}`;
        });
        this.state.replaced = (this.state.prior != null) || (this.state.value != null);
        return this.update(value, opts);
      }

      // ### merge (value)

        // Performs a granular merge of `value` into existing `@value` if
      // available, otherwise performs [set](#set-value) operation.
      merge(value, opts = {}) {
        if (opts.origin == null) {
          opts.origin = this;
        }
        if (value === null) {
          return this.delete(opts);
        }
        return this.set(value, opts);
      }

      // ### delete
      delete(opts = {}) {
        var e, ref;
        if (opts.origin == null) {
          opts.origin = this;
        }
        if (this.state.value == null) {
          //return this if @state.value is null
          return this;
        }
        if (!opts.force && (((ref = this.binding) != null ? ref.delete : void 0) != null)) {
          try {
            this.binding.delete(this.context.with(opts), null);
          } catch (error) {
            e = error;
            throw this.error(e, 'delete');
          }
        }
        return this.update(null, opts);
      }

      // ### update

        // Updates the value to the data model. Called *once* for each node that
      // is part of the change branch.
      update(value, opts = {}) {
        var base, ref;
        if (opts.origin == null) {
          opts.origin = this;
        }
        (base = this.state).changed || (base.changed = this.state.value !== value);
        this.state.value = value;
        if ((ref = this.parent) != null) {
          ref.update(this, opts);
        }
        return this;
      }

      // ### commit async transaction

        // Commits the changes to the data model. Called *once* for each node that
      // is part of the change branch.
      lock(opts = {}) {
        this.state.locked = true;
        this.state.delta = this.change;
        opts.lock = this;
        return this;
      }

      unlock(opts = {}) {
        this.state.locked = false;
        // @state.delta = undefined
        delete opts.lock;
        return this;
      }

      async commit(opts = {}) {
        var err, ref, ref1, ref2;
        if (!this.changed) {
          return this;
        }
        try {
          await this.lock(opts);
          
          // 1. perform the bound commit transaction
          if (!opts.sync && (((ref = this.binding) != null ? ref.commit : void 0) != null)) {
            this.debug(() => {
              return "[commit] execute commit binding...";
            });
            await ((ref1 = this.binding) != null ? typeof ref1.commit === "function" ? ref1.commit(this.context.with(opts)) : void 0 : void 0);
          }
          if (!opts.inner) {
            // 2. wait for the parent to commit unless called by parent
            await ((ref2 = this.parent) != null ? typeof ref2.commit === "function" ? ref2.commit(opts) : void 0 : void 0);
          }
          if (this.parent == null) {
            // 3. self-clean only if no parent
            this.clean(opts);
          }
        } catch (error) {
          err = error;
          this.debug(() => {
            return `[commit] revert due to ${err.message}`;
          });
          await this.revert(opts);
          throw this.error(err, 'commit');
        } finally {
          this.unlock(opts);
        }
        return this;
      }

      async revert(opts = {}) {
        var err, id, ref, temp;
        if (!this.changed) {
          return;
        }
        id = opts.seq;
        this.debug(`[revert:${id}] changing back from:`, this.state.value);
        this.debug(`[revert:${id}] changing back to:`, this.state.prior);
        temp = this.state.value;
        this.state.value = this.state.prior;
        this.state.prior = temp; // preserve what we were trying to change to within commit context
        if (!opts.sync) {
          this.debug(`[revert:${id}] execute binding...`);
        }
        try {
          if (!opts.sync) {
            await ((ref = this.binding) != null ? typeof ref.commit === "function" ? ref.commit(this.context.with(opts)) : void 0 : void 0);
          }
        } catch (error) {
          err = error;
          this.debug(`[revert:${id}] failed due to: ${err.message}`);
        }
        // throw @error err, 'revert'
        this.debug(`[revert:${id}] cleaning up...`);
        return this.clean(opts);
      }

      clean(opts = {}) {
        // @state.prior = @state.value # save current value as prior
        this.state.prior = this.toJSON(); // save copy of current data as prior
        this.state.changed = false;
        this.state.replaced = false;
        return this.debug(`[clean:${opts.seq}] finalized commit, persisted:`, this.state.prior);
      }

      // ### attach (obj, parent, opts)

        // This call is the primary mechanism via which the `Property` instance
      // attaches itself to the provided target `obj`. It defines itself in the
      // target `obj` via `Object.defineProperty`.
      attach(obj, parent, opts) {
        var name;
        if (!(obj instanceof Object)) {
          return obj;
        }
        if (opts == null) {
          opts = {
            replace: false,
            force: false
          };
        }
        this.parent = parent;
        // if joining for the first time, apply existing data unless explicit replace
        if (!this.attached) {
          // @debug "[attach] applying existing data for #{@name} (external: #{@external}) to:"
          // @debug obj
          name = (function() {
            var ref;
            switch (false) {
              case !(((ref = this.parent) != null ? ref.external : void 0) && this.tag in obj):
                return this.tag;
              case !this.external:
                return this.name;
              case !(this.name in obj):
                return this.name;
              default:
                return `${this.root.name}:${this.name}`;
            }
          }).call(this);
          this.set(obj[name], Object.assign({}, opts, {
            inner: true
          }));
        }
        if (!opts.preserve) {
          try {
            Object.defineProperty(obj, this.name, {
              configurable: true,
              enumerable: this.enumerable,
              get: (...args) => {
                return this.get(...args);
              },
              set: (...args) => {
                return this.set(...args);
              }
            });
          } catch (error) {}
        }
        this.state.attached = true;
        this.debug(() => {
          return `[attach] attached into ${obj.constructor.name} container`;
        });
        return obj;
      }

      // ### find (pattern)

        // This helper routine can be used to allow traversal to other elements
      // in the data tree from the relative location of the current `Property`
      // instance. It returns matching `Property` instances based on the
      // provided `pattern` in the form of XPATH or YPATH.

        // It is internally used via [get](#get) and generally used inside
      // controller logic bound inside the [Yang expression](./yang.litcoffee)
      // as well as event handler listening on [Model](./model.litcoffee)
      // events.

        // It *always* returns an array (empty to denote no match) unless it
      // encounters an error, in which case it will throw an Error.
      find(pattern = '.', opts = {}) {
        var ref, ref1;
        this.debug(() => {
          return `[find] ${pattern}`;
        });
        pattern = XPath.parse(pattern, this.schema);
        switch (false) {
          case !(pattern.tag === '/' && this !== this.root):
            return this.root.find(pattern);
          case pattern.tag !== '..':
            return (ref = this.parent) != null ? ref.find(pattern.xpath) : void 0;
          default:
            return (ref1 = pattern.apply(this)) != null ? ref1 : [];
        }
      }

      // ### in (pattern)

        // A convenience routine to locate one or more matching Property
      // instances based on `pattern` (XPATH or YPATH) from this Model.
      in(pattern) {
        var props;
        try {
          props = this.find(pattern);
        } catch (error) {}
        if (!((props != null) && props.length)) {
          return;
        }
        switch (false) {
          case !(props.length > 1):
            return props;
          default:
            return props[0];
        }
      }

      // ### defer (value)

        // Optionally defer setting the value to the property until root has been updated.
      defer(value) {
        this.debug(() => {
          return `deferring '${this.kind}(${this.name})' until update at ${this.root.name}`;
        });
        this.root.once('update', () => {
          this.debug(() => {
            return `applying deferred data (${typeof value})`;
          });
          return this.data = value;
        });
        return value;
      }

      
        // ### error (msg)

        // Provides more contextual error message pertaining to the Property instance.
      error(err, ctx) {
        var ref;
        if (!(err instanceof Error)) {
          err = new Error(err);
        }
        if (err.uri == null) {
          err.uri = this.uri;
        }
        if (err.src == null) {
          err.src = this;
        }
        if (err.ctx == null) {
          err.ctx = ctx;
        }
        switch (false) {
          case ((ref = this.binding) != null ? ref.error : void 0) == null:
            return this.binding.error(err);
          default:
            return err;
        }
      }

      // ### toJSON

        // This call creates a new copy of the current `Property.content`
      // completely detached/unbound to the underlying data schema. It's main
      // utility is to represent the current data state for subsequent
      // serialization/transmission. It accepts optional argument `tag` which
      // when called with `true` will tag the produced object with the current
      // property's `@name`.
      toJSON(key, state = true) {
        var value;
        value = (function() {
          switch (false) {
            case this.kind !== 'anydata':
              return void 0;
            case !(state !== true && !this.mutable):
              return void 0;
            default:
              return this.data;
          }
        }).call(this);
        if (key === true) {
          value = {
            [`${this.name}`]: value
          };
        }
        return value;
      }

      // ### inspect
      inspect() {
        return {
          name: this.name,
          kind: this.kind,
          path: this.path.toString(),
          active: this.active,
          private: this.private,
          mutable: this.mutable,
          changed: this.changed,
          schema: (function() {
            var ref;
            switch (false) {
              case this.schema.uri == null:
                return {
                  uri: this.schema.uri,
                  summary: (ref = this.schema.description) != null ? ref.tag : void 0,
                  datakey: this.schema.datakey,
                  datapath: this.schema.datapath,
                  external: this.schema.external,
                  children: this.schema.children.map(function(x) {
                    return x.uri;
                  })
                };
              default:
                return false;
            }
          }).call(this),
          value: this.toJSON()
        };
      }

    };

    Property.prototype.logger = debug('yang:property');

    delegate(Property.prototype, 'state').access('parent').access('strict').getter('private').getter('mutable').getter('attached').getter('replaced').getter('changed').getter('locked').getter('prior').getter('value');

    delegate(Property.prototype, 'schema').getter('tag').getter('kind').getter('type').getter('default').getter('external').getter('binding').method('locate').method('lookup');

    // ### Computed Properties
    Property.property('key', {
      get: function() {
        return this.name;
      }
    });

    Property.property('value', {
      get: function() {
        return this.state.value;
      }
    });

    Property.property('data', {
      set: function(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function() {
        var ref;
        switch (false) {
          case ((ref = this.binding) != null ? ref.get : void 0) == null:
            return this.binding.get(this.context);
          default:
            return this.value;
        }
      }
    });

    Property.property('enumerable', {
      get: function() {
        return !this.private && ((this.value != null) || (this.binding != null));
      }
    });

    Property.property('active', {
      get: function() {
        return this.enumerable && (this.value != null);
      }
    });

    Property.property('change', {
      get: function() {
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !this.changed:
            return this.data;
        }
      }
    });

    Property.property('context', {
      get: function() {
        var ctx;
        ctx = Object.create(context);
        ctx.opts = {};
        ctx.node = this;
        Object.preventExtensions(ctx);
        return ctx;
      }
    });

    Property.property('root', {
      get: function() {
        var root;
        if (this.kind === 'module') {
          return this;
        }
        root = (function() {
          switch (false) {
            case this.parent !== this:
              return this;
            case !(this.parent instanceof Property):
              return this.parent.root;
            default:
              return this;
          }
        }).call(this);
        if (this.state.root !== root) {
          this.state.path = void 0;
        }
        return this.state.root = root;
      }
    });

    Property.property('path', {
      get: function() {
        var base, entity;
        if (this === this.root) {
          entity = (function() {
            switch (false) {
              case this.kind !== 'module':
                return '/';
              default:
                return '.';
            }
          }).call(this);
          return XPath.parse(entity, this.schema);
        }
        if ((base = this.state).path == null) {
          base.path = this.parent.path.clone().append(this.key);
        }
        return this.state.path;
      }
    });

    Property.property('uri', {
      get: function() {
        var ref;
        switch (false) {
          case !((this.parent != null) && (this.parent.uri != null)):
            return `${this.parent.uri}/${this.key}`;
          case this.parent == null:
            return this.key;
          default:
            return (ref = this.schema.datapath) != null ? ref : this.schema.uri;
        }
      }
    });

    return Property;

  }).call(this);

  // ## Export Property Class
  module.exports = Property;

}).call(this);
