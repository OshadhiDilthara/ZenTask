// Generated by CoffeeScript 2.5.1
(function() {
  // # Container - controller of object properties

  // ## Class Container
  var Container, Emitter, Property, delegate, kProp,
    hasProp = {}.hasOwnProperty;

  delegate = require('delegates');

  Emitter = require('events').EventEmitter;

  Property = require('./property');

  kProp = Symbol.for('property');

  Container = (function() {
    class Container extends Property {
      constructor() {
        super(...arguments);
        this.state.children = new Map(); // committed props
        this.state.pending = new Map(); // uncommitted changed props
        this.state.delta = void 0;
        this.state.locked = false;
        this.state.proxy = {
          has: (obj, key) => {
            return this.children.has(key) || key in obj;
          },
          get: (obj, key) => {
            switch (false) {
              case key !== kProp:
                return this;
              case key !== '_':
                return this;
              case key !== 'toJSON':
                return this.toJSON.bind(this);
              case !this.has(key):
                return this.get(key);
              case !(key in obj):
                return obj[key];
              case key !== 'inspect':
                return this.toJSON.bind(this);
              case !(key in this && typeof this[key] === 'function'):
                return this[key].bind(this);
              case !(typeof key === 'string' && key[0] === '_'):
                return this[key.substring(1)];
            }
          },
          set: (obj, key, value) => {
            switch (false) {
              case !this.has(key):
                return this._get(key).set(value);
              default:
                return obj[key] = value;
            }
          },
          deleteProperty: (obj, key) => {
            switch (false) {
              case !this.has(key):
                return this._get(key).delete();
              case !(key in obj):
                return delete obj[key];
            }
          }
        };
        Object.setPrototypeOf(this.state, Emitter.prototype);
      }

      clone() {
        var copy, i, len, prop, ref;
        copy = super.clone({
          children: new Map(),
          pending: new Map()
        });
        ref = this.props;
        for (i = 0, len = ref.length; i < len; i++) {
          prop = ref[i];
          copy.add(prop.clone({
            parent: copy
          }));
        }
        return copy;
      }

      // ### add (child)

        // This call is used to add a child property to map of children.
      add(child) {
        this.children.set(child.key, child);
        if (this.value != null) {
          return Object.defineProperty(this.value, child.key, {
            configurable: true,
            enumerable: child.active
          });
        }
      }

      // ### remove (child)

        // This call is used to remove a child property from map of children.
      remove(child) {
        this.children.delete(child.key);
        if (this.value != null) {
          return delete this.value[child.key];
        }
      }

      // ### has (key)
      has(key) {
        return this.children.has(key);
      }

      // ### get (key)
      _get(key) {
        return this.children.get(key);
      }

      get(key) {
        switch (false) {
          case !((key != null) && this.has(key)):
            return this._get(key).data;
          default:
            return super.get(...arguments);
        }
      }

      // ### set (obj, opts)
      set(obj, opts = {}) {
        var subopts;
        // TODO: should we preserve prior changes and restore if super fails?
        this.pending.clear();
        try {
          if (kProp in obj) {
            // TODO: should we also clear Object.defineProperties?
            obj = Object.assign({}, obj);
          }
        } catch (error) {}
        super.set(obj, opts);
        // remove all props not part of pending changes
        subopts = Object.assign({}, opts);
        //prop.delete(subopts) for prop in @props when not @pending.has(prop.key)
        this.props.forEach((prop) => {
          if (!this.pending.has(prop.key)) {
            return prop.delete(subopts);
          }
        });
        return this;
      }

      // ### merge (obj, opts)

        // Enumerate key/value of the passed in `obj` and merge into known child
      // properties.
      merge(obj, opts = {}) {
        var deep, k, prop, ref, subopts, v;
        if (opts.origin == null) {
          opts.origin = this;
        }
        if (obj === null) {
          return this.delete(opts);
        }
        if (opts.replace || (this.value == null)) {
          return this.set(obj, opts);
        }
        
          // TODO: protect this as a transaction?
        ({deep = true} = opts);
        subopts = Object.assign({}, opts, {
          inner: true,
          replace: !deep
        });
        for (k in obj) {
          if (!hasProp.call(obj, k)) continue;
          v = obj[k];
          this.debug(() => {
            return `[merge] looking for ${k} inside ${this.children.size} children`;
          });
          prop = (ref = this.children.get(k)) != null ? ref : this.in(k);
          if (!((prop != null) && !Array.isArray(prop))) {
            continue;
          }
          this.debug(() => {
            return `[merge] applying value to child prop ${prop.key}`;
          });
          prop.merge(v, subopts);
        }
        // TODO: we should consider evaluating schema.attrs here before calling update

        return this.update(this, opts);
      }

      // ### update

        // Updates the value to the data model. Called *once* for each node that
      // is part of the change branch.
      update(value, opts = {}) {
        var prop, ref;
        if (opts.origin == null) {
          opts.origin = this;
        }
        if (value instanceof Property) {
          // handle updating pending map if value is a child prop
          if (value.parent === this) {
            this.pending.set(value.key, value);
            this.debug(() => {
              return `[update] pending.set '${value.key}' now have ${this.pending.size} pending changes`;
            });
          }
          if (value !== this) {
            if (opts.inner || opts.origin === this) {
              // return right away if part of update on a higher node
              return this;
            }
            // higher up the tree from change origin and continue
            value = this.value;
          }
        }
        this.debug(() => {
          return `[update] handle ${this.pending.size} changed props`;
        });
        ref = this.changes;
        for (prop of ref) {
          this.debug(() => {
            return `[update] child ${prop.uri} changed? ${prop.changed}`;
          });
          this.add(prop, opts);
          if (!prop.changed) {
            this.pending.delete(prop.key);
          }
        }
        if (value === this) {
          // dynamically compute value to be used for storing into @state
          value = this.value;
        }
        if (value === null) {
          // we must clear children here if being deleted before calling super (which calls parent.update)
          this.children.clear();
        }
        super.update(value, opts);
        this.emit('update', this, opts);
        return this;
      }

      // ### commit (opts)

        // Commits the changes to the data model. Async transaction.
      // Events: commit, change
      async lock(opts = {}) {
        var randomize;
        randomize = function(min, max) {
          return Math.floor(Math.random() * (max - min)) + min;
        };
        if (opts.seq == null) {
          opts.seq = randomize(1000, 9999);
        }
        this.debug(`[lock:${opts.seq}] acquiring lock... already have it?`, opts.lock === this);
        if (opts.lock !== this) {
          while (this.locked) {
            await (new Promise((resolve) => {
              return this.once('ready', function() {
                return resolve(true);
              });
            }));
          }
        }
        this.debug(`[lock:${opts.seq}] acquired and has ${this.pending.size} changes, changed? ${this.changed}`);
        if (opts.caller != null) {
          this.debug(`[lock:${opts.seq}] acquired by ${opts.caller.uri} and locked? ${opts.caller.locked}`);
        }
        return super.lock(opts);
      }

      unlock(opts = {}) {
        this.debug(`[unlock:${opts.seq}] freeing lock...`);
        if (!this.locked) {
          return this;
        }
        super.unlock(opts);
        this.emit('ready');
        return this;
      }

      async commit(opts = {}) {
        var err, failed, id, ref, ref1, ref2, subopts;
        try {
          await this.lock(opts);
          id = (ref = opts.seq) != null ? ref : 0;
          if (this.changed) {
            subopts = Object.assign({}, opts, {
              caller: this,
              inner: true
            });
            delete subopts.lock;
            // 1. commit all the changed children
            this.debug(`[commit:${id}] wait to commit all the children...`);
            await Promise.all(this.changes.filter(function(p) {
              return !p.locked;
            }).map(function(prop) {
              return prop.commit(subopts);
            }));
            // 2. run the commit binding
            if (!opts.sync && (((ref1 = this.binding) != null ? ref1.commit : void 0) != null)) {
              this.debug(`[commit:${id}] executing commit binding...`);
              await this.binding.commit(this.context.with(opts));
            }
          }
          
          // wait for the parent to commit unless called by parent
          if (opts.origin == null) {
            opts.origin = this;
          }
          if (!opts.inner) {
            subopts = Object.assign({}, opts, {
              caller: this
            });
            this.debug(`[commit:${id}] wait for parent to commit...`);
            await ((ref2 = this.parent) != null ? typeof ref2.commit === "function" ? ref2.commit(subopts) : void 0 : void 0);
          }
          if (!opts.suppress && !opts.inner) {
            this.emit('change', opts.origin, opts.actor);
          }
          if (!opts.inner) {
            this.clean(opts);
          }
        } catch (error) {
          err = error;
          this.debug(`[commit:${id}] error: ${err.message}`);
          failed = true;
          throw this.error(err, 'commit');
        } finally {
          this.debug(`[commit:${id}] finalizing... successful? \${!failed}`);
          if (failed) {
            await this.revert(opts);
          }
          this.debug(`[commit:${id}] ${this.pending.size} changes, now have ${this.children.size} props, releasing lock!`);
          this.unlock(opts);
        }
        return this;
      }

      async revert(opts = {}) {
        var copy, id, prop, ref, ref1;
        if (!this.changed) {
          return;
        }
        id = (ref = opts.seq) != null ? ref : 0;
        this.debug(() => {
          return `[revert:${id}] changing back ${this.pending.size} pending changes...`;
        });
        // NOTE: save a copy of current data here since reverting changed children may alter @state.value
        copy = this.toJSON();
        ref1 = this.changes;
        
        // XXX: may want to consider Promise.all here
        for (prop of ref1) {
          if (!((!prop.locked) || (prop === opts.caller))) {
            continue;
          }
          this.debug(`[revert:${id}] changing back: ${prop.key}`);
          await prop.revert(opts);
          this.add(prop);
        }
        // XXX: need to deal with scenario where child nodes reverting is sufficient?

        // below is hackish but works to make a copy of current value
        // to be used as ctx.prior during revert commit binding call
        this.state.value = copy;
        await super.revert(opts);
        return this.debug(`[revert:${id}] ${this.children.size} remaining props`);
      }

      clean(opts = {}) {
        var id, prop, ref;
        if (!this.changed) {
          return;
        }
        // traverse down committed nodes and clean their state
        // console.warn(opts.caller) if opts.caller
        id = opts.seq;
        this.debug(`[clean:${id}] ${this.pending.size} changes with ${this.children.size} props`);
        if (this.state.value == null) {
          this.children.clear();
          this.pending.clear();
        } else {
          ref = this.changes;
          for (prop of ref) {
            if (!((!prop.locked) || (prop === opts.caller))) {
              continue;
            }
            prop.clean(opts);
            this.pending.delete(prop.key);
          }
        }
        this.debug(`[clean:${id}] ${this.pending.size} remaining changes`);
        return super.clean(opts);
      }

      
        // ### toJSON

        // This call creates a new copy of the current `Property.data`
      // completely detached/unbound to the underlying data schema. It's main
      // utility is to represent the current data state for subsequent
      // serialization/transmission. It accepts optional argument `tag` which
      // when called with `true` will tag the produced object with the current
      // property's `@name`.
      toJSON(key, state = true) {
        var obj, prop, props, value;
        props = this.props;
        value = (function() {
          var i, len;
          switch (false) {
            case !props.length:
              obj = {};
              for (i = 0, len = props.length; i < len; i++) {
                prop = props[i];
                if (!(prop.enumerable && (state || prop.mutable))) {
                  continue;
                }
                value = prop.toJSON(false, state);
                if (value != null) {
                  obj[prop.key] = value;
                }
              }
              return obj;
            default:
              return this.value;
          }
        }).call(this);
        if (key === true) {
          value = {
            [`${this.name}`]: value
          };
        }
        return value;
      }

      // ### inspect
      inspect() {
        var output;
        output = super.inspect(...arguments);
        return Object.assign(output, {
          children: this.children.size
        });
      }

    };

    Container.prototype.logger = require('debug')('yang:container');

    delegate(Container.prototype, 'state').getter('children').getter('pending').getter('locked').getter('delta').method('once').method('on').method('off').method('emit');

    Container.property('props', {
      get: function() {
        return Array.from(this.children.values());
      }
    });

    Container.property('changed', {
      get: function() {
        return this.pending.size > 0 || this.state.changed;
      }
    });

    Container.property('changes', {
      get: function() {
        return Array.from(this.pending.values());
      }
    });

    Container.property('change', {
      get: function() {
        var obj, prop, ref;
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !(this.changed && this.pending.size):
            obj = {};
            ref = this.changes;
            for (prop of ref) {
              obj[prop.key] = prop.change;
            }
            return obj;
          case !this.changed:
            return this.data;
        }
      }
    });

    Container.property('data', {
      set: function(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function() {
        var value;
        value = (function() {
          var ref;
          switch (false) {
            case ((ref = this.binding) != null ? ref.get : void 0) == null:
              return this.binding.get(this.context);
            default:
              return this.value;
          }
        }).call(this);
        if (!(value instanceof Object)) {
          return value;
        }
        return new Proxy(value, this.state.proxy);
      }
    });

    return Container;

  }).call(this);

  module.exports = Container;

}).call(this);
