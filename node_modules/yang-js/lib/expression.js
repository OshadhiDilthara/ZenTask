// Generated by CoffeeScript 2.5.1
(function() {
  // expression - evaluable Element
  var Element, Expression, delegate;

  delegate = require('delegates');

  Element = require('./element');

  Expression = (function() {
    class Expression extends Element {
      //debug: (f) -> if debug.enabled logger.namespace then logger @uri, [].concat(f())...
      constructor(kind, tag, source) {
        var evaluate, self;
        super(kind, tag);
        this.source = source;
        evaluate = (function() {
          return self.eval(...arguments);
        });
        self = Object.setPrototypeOf(evaluate, this);
        Object.defineProperties(self, {
          inspect: {
            value: function() {
              return this.toJSON();
            }
          }
        });
        delete self.length; // TODO: this may not work for Edge browser...
        return self;
      }

      clone() {
        var copy;
        copy = super.clone(...arguments);
        if (this.convert != null) {
          copy.convert = this.convert;
        }
        return copy;
      }

      compile() {
        var ref;
        this.debug(() => {
          return `[compile] enter... (${this.resolved})`;
        });
        this.emit('compiling', arguments);
        if (!this.resolved) {
          if ((ref = this.resolve) != null) {
            ref.apply(this, arguments);
          }
        }
        if ((this.tag != null) && !this.argument) {
          throw this.error(`cannot contain argument '${this.tag}' for expression '${this.kind}'`);
        }
        if (this.argument && (this.tag == null)) {
          throw this.error(`must contain argument '${this.argument}' for expression '${this.kind}'`);
        }
        if (this.exprs.length) {
          this.debug(() => {
            return `has sub-expressions: ${this.exprs.map(function(x) {
              return x.kind;
            })}`;
          });
        }
        this.exprs.forEach(function(x) {
          return x.compile();
        });
        this.resolved = true;
        this.emit('compiled');
        this.debug(() => {
          return "[compile] done";
        });
        return this;
      }

      bind(data) {
        if (data != null) {
          this.debug(() => {
            return `[bind] registering ${typeof data} binding`;
          });
          this.binding = data;
          this.emit('bind', data); // allows unbinding...
        } else {
          this.debug(() => {
            return `[bind] removing prior ${typeof this.binding} binding`;
          });
          this.binding = void 0;
        }
        return this;
      }

      // internally used to apply the expression to the passed in data
      apply(data, ctx, opts) {
        var e, expr, i, len, ref, ref1;
        if (!this.resolved) {
          this.compile();
        }
        this.emit('transforming', data);
        if (this.transform instanceof Function) {
          data = this.transform.call(this, data, ctx, opts);
        } else {
          ref = this.exprs;
          for (i = 0, len = ref.length; i < len; i++) {
            expr = ref[i];
            if (data != null) {
              data = expr.eval(data, ctx, opts);
            }
          }
        }
        try {
          if ((ref1 = this.predicate) != null) {
            ref1.call(this, data, opts);
          }
        } catch (error) {
          e = error;
          this.debug(() => {
            return data;
          });
          throw this.error(`predicate validation error: ${e}`, data);
        }
        this.emit('transformed', data);
        return data;
      }

      // evalute the provided data
      eval(data, ctx, opts) {
        if (!this.resolved) {
          this.compile();
        }
        if (this.construct instanceof Function) {
          if (data == null) {
            data = {};
          }
          return this.construct.call(this, data, ctx, opts);
        } else {
          return this.apply(data, ctx, opts);
        }
      }

      update(elem) {
        var res;
        res = super.update(...arguments);
        res.binding = elem.binding;
        return res;
      }

      error() {
        var res;
        res = super.error(...arguments);
        res.message = `[${this.uri}] ${res.message}`;
        res.name = 'ExpressionError';
        return res;
      }

    };

    Expression.prototype.logger = require('debug')('yang:expression');

    
    // Source delegation

    delegate(Expression.prototype, 'source').getter('scope').getter('resolve').getter('transform').getter('construct').getter('predicate').getter('compose');

    delegate(Expression.prototype, 'state').access('binding').access('resolved');

    Expression.property('argument', {
      get: function() {
        var ref;
        return (ref = this.state.argument) != null ? ref : this.source.argument;
      },
      set: function(value) {
        return this.state.argument = value;
      }
    });

    Expression.property('exprs', {
      get: function() {
        return this.children.filter(function(x) {
          return x instanceof Expression;
        });
      }
    });

    Expression.property('nodes', {
      get: function() {
        return this.exprs.filter(function(x) {
          return x.node === true;
        });
      }
    });

    Expression.property('attrs', {
      get: function() {
        return this.exprs.filter(function(x) {
          return x.node === false;
        });
      }
    });

    Expression.property('node', {
      get: function() {
        return this.construct instanceof Function;
      }
    });

    Expression.property('data', {
      get: function() {
        return Boolean(this.source.data);
      }
    });

    Expression.property('*', {
      get: function() {
        return this.nodes;
      }
    });

    return Expression;

  }).call(this);

  module.exports = Expression;

}).call(this);
