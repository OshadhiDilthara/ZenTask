// Generated by CoffeeScript 2.5.1
(function() {
  var Container, List, ListItem, Property, XPath, delegate;

  delegate = require('delegates');

  Container = require('./container');

  Property = require('./property');

  XPath = require('./xpath');

  ListItem = (function() {
    class ListItem extends Container {
      merge() {
        var prevkey, ref;
        prevkey = this.key;
        super.merge(...arguments);
        if (prevkey !== this.key) {
          if ((ref = this.parent) != null) {
            if (typeof ref.remove === "function") {
              ref.remove({
                key: prevkey
              });
            }
          }
        }
        return this;
      }

      update(value, opts) {
        // @debug => "[update] prior key is: #{@key}"
        if (this.keys.length && (value != null) && !(value instanceof Property)) {
          if ('@key' in value) {
            this.state.key = value['@key'];
          }
        }
        // @debug => "[update] current key is: #{@key}"
        return super.update(...arguments);
      }

      attach(obj, parent, opts) {
        if (!(obj instanceof Object)) {
          throw this.error("list item must be an object", 'attach');
        }
        if (opts == null) {
          opts = {
            replace: false,
            force: false
          };
        }
        this.parent = parent;
        if (!this.keys.length) {
          this.state.key = this;
        }
        // list item directly applies the passed in object
        this.set(obj, opts);
        this.state.attached = true;
        return obj;
      }

      async revert(opts) {
        var ref;
        if (!this.changed) {
          return;
        }
        await super.revert(opts);
        return (ref = this.parent) != null ? ref.update(this) : void 0;
      }

      find(pattern) {
        switch (false) {
          // here we skip a level of hierarchy
          case !(/^\.\./.test(pattern) && (this.parent != null)):
            return this.parent.find(...arguments);
          default:
            return super.find(...arguments);
        }
      }

      inspect() {
        var res;
        res = super.inspect(...arguments);
        res.key = this.key;
        res.keys = this.keys;
        return res;
      }

    };

    ListItem.prototype.logger = require('debug')('yang:list:item');

    delegate(ListItem.prototype, 'state').getter('key');

    ListItem.property('uri', {
      get: function() {
        var ref;
        switch (false) {
          case this.parent == null:
            return `${this.parent.uri}['${this.key}']`;
          default:
            return (ref = this.schema.datapath) != null ? ref : this.schema.uri;
        }
      }
    });

    
    // @property 'uri',
    //   get: -> (@schema.datapath ? @schema.uri) + "['#{@key}']" 
    ListItem.property('keys', {
      get: function() {
        if (this.schema.key) {
          return this.schema.key.tag;
        } else {
          return [];
        }
      }
    });

    ListItem.property('pos', {
      get: function() {
        if (this.parent != null) {
          return (this.parent.props.findIndex((x) => {
            return x === this;
          })) + 1;
        }
      }
    });

    ListItem.property('path', {
      get: function() {
        var entity;
        entity = (function() {
          switch (false) {
            case !this.keys.length:
              return `.['${this.key}']`;
            default:
              return `.[${this.pos}]`;
          }
        }).call(this);
        if (this.parent == null) {
          return XPath.parse(entity, this.schema);
        }
        // XXX - do not cache into @state.path since keys may change...
        return this.parent.path.clone().append(entity);
      }
    });

    return ListItem;

  }).call(this);

  List = (function() {
    class List extends Container {
      // private methods
      _key(s) {
        return `key(${s})`;
      }

      add(child, opts = {}) {
        var key;
        if (!child.active) {
          return;
        }
        if (this.schema.key != null) {
          key = this._key(child.key);
          if (this.has(key) && this._get(key) !== child) {
            this.pending.delete(child.key);
            throw this.error(`cannot update due to key conflict: ${child.key}`, 'add');
          }
          return this.children.set(key, child);
        } else {
          return this.children.set(child);
        }
      }

      remove(child, opts = {}) {
        var key;
        if (this.schema.key != null) {
          key = this._key(child.key);
          if (this._get(key) === child) {
            return this.children.delete(key);
          }
        } else {
          return this.children.delete(child);
        }
      }

      equals(a, b) {
        if (!(Array.isArray(a) && Array.isArray(b) && a.length === b.length)) {
          return false;
        }
        // figure out how to deal with empty array later...
        // return true if a.length is 0
        return false;
      }

      // a.every (x) => b.some (y) => x is y

        // public methods
      has(key) {
        return typeof key === 'string' && (this.schema.key != null) && super.has(key);
      }

      set(data, opts = {}) {
        var err, prev;
        if ((data != null) && !Array.isArray(data)) {
          throw this.error("list must be an array", 'set');
        }
        if (data != null) {
          data = [].concat(data).filter(Boolean);
        }
        prev = this.props;
        this.children.clear();
        try {
          super.set(data, opts);
        } catch (error) {
          err = error;
          this.children.clear();
          prev.forEach((prop) => {
            return this.add(prop);
          });
          throw err;
        }
        return this;
      }

      merge(data, opts = {}) {
        var creates, e, item, j, key, len, subopts;
        if (opts.origin == null) {
          opts.origin = this;
        }
        if (data != null) {
          data = [].concat(data).filter(Boolean);
        }
        if (data === null) {
          return this.delete(opts);
        }
        if (!this.children.size || opts.replace) {
          return this.set(data, opts);
        }
        if (data == null) {
          return this; // do nothing if data is undefined
        }
        creates = [];
        subopts = Object.assign({}, opts, {
          inner: true
        });
        for (j = 0, len = data.length; j < len; j++) {
          item = data[j];
          if ((this.schema.key != null) && !opts.createOnly) {
            //pre = process.memoryUsage()
            item = this.schema.key.apply(item);
            key = this._key(item['@key']);
            if (this.has(key)) {
              if (!opts.appendOnly) {
                this.debug(() => {
                  return `[merge] merge into list item for ${key}`;
                });
                this.debug(() => {
                  return item;
                });
                this._get(key).merge(item, subopts);
                this.debug(() => {
                  return `[merge] merge done for list item ${key}`;
                });
              }
              //post = process.memoryUsage()
              //console.log("item growth: %d KB", (post.heapUsed - pre.heapUsed) / 1024);    
              continue;
            }
          }
          creates.push(item);
        }
        try {
          if (creates.length) {
            this.schema.apply(creates, this, subopts);
          }
        } catch (error) {
          e = error;
          throw this.error(e, 'create');
        }
        return this.update(this, opts); // pass itself if merging
      }

      update(value, opts) {
        if (value instanceof ListItem && !value.active) {
          this.remove(value);
        }
        return super.update(value, opts);
      }

      async revert(opts = {}) {
        var err, ref;
        if (!this.changed) {
          return;
        }
        if (!this.replaced) {
          return super.revert(opts);
        }
        // TODO: find a more optimal way to revert entire list?
        this.debug("[revert] complete list...");
        this.set(this.state.prior, {
          force: true // this will trigger 'update' events!
        });
        if (!opts.sync) {
          this.debug("[revert] execute binding...");
        }
        try {
          if (!opts.sync) {
            await ((ref = this.binding) != null ? typeof ref.commit === "function" ? ref.commit(this.context.with(opts)) : void 0 : void 0);
          }
        } catch (error) {
          err = error;
          this.debug(`[revert] failed due to ${err.message}`);
          throw this.error(err, 'revert');
        }
        return this.clean(opts);
      }

      toJSON(key, state = true) {
        var value;
        value = (function() {
          switch (false) {
            case !this.children.size:
              return this.props.map(function(x) {
                return x.toJSON(false, state);
              });
            default:
              return this.value;
          }
        }).call(this);
        if (key === true) {
          value = {
            [`${this.name}`]: value
          };
        }
        return value;
      }

    };

    List.prototype.logger = require('debug')('yang:list');

    List.Item = ListItem;

    List.property('value', {
      get: function() {
        switch (false) {
          case this.state.value == null:
            return this.props.map(function(item) {
              return item.data;
            }).filter(Boolean);
          default:
            return [];
        }
      }
    });

    List.property('props', {
      get: function() {
        switch (false) {
          case this.schema.key == null:
            return Array.from(this.children.values());
          default:
            return Array.from(this.children.keys());
        }
      }
    });

    List.property('changed', {
      get: function() {
        return this.pending.size > 0 || (this.state.changed && !this.active);
      }
    });

    List.property('active', {
      get: function() {
        return this.enumerable && this.children.size > 0;
      }
    });

    List.property('change', {
      get: function() {
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !(this.changed && this.pending.size):
            return Array.from(this.changes).filter(function(i) {
              return i.active;
            }).map(function(i) {
              var j, k, len, obj, ref;
              obj = i.change;
              if (obj != null) {
                ref = i.keys;
                for (j = 0, len = ref.length; j < len; j++) {
                  k = ref[j];
                  obj[k] = i.get(k);
                }
              }
              return obj;
            });
        }
      }
    });

    return List;

  }).call(this);

  module.exports = List;

}).call(this);
