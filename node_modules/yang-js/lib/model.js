// Generated by CoffeeScript 2.5.1
(function() {
  // # Model - instance of schema-driven data

  // The `Model` class aggregates [Property](./property.litcoffee)
  // attachments to provide the *adaptive* and *event-driven* data
  // interactions.

  // It is typically not instantiated directly, but is generated as a
  // result of [Yang::eval](../yang.litcoffee#eval-data-opts) for a YANG
  // `module` schema.

  // ```javascript
  // var schema = Yang.parse('module foo { container bar { leaf a { type uint8; } } }');
  // var model = schema.eval({ 'foo:bar': { a: 7 } });
  // // model is { 'foo:bar': [Getter/Setter] }
  // ```

  // The generated `Model` is a hierarchical composition of
  // [Property](./property.litcoffee) instances. The instance itself uses
  // `Object.preventExtensions` to ensure no additional properties that are
  // not known to itself can be added.

  // It is designed to provide *stand-alone* interactions on a per-module
  // basis. For flexible management of multiple modules (such as hotplug
  // modules) and data persistence, please take a look at the
  // [yang-store](http://github.com/corenova/yang-store) project.

  // Below are list of properties available to every instance of `Model`
  // (it also inherits properties from [Property](./property.litcoffee)):

  // property | type | mapping | description
  // --- | --- | --- | ---
  // transactable | boolean | computed | getter/setter for `state.transactable`
  // instance | Emitter | access(state) | holds runtime features

  // ## Dependencies
  var Container, Emitter, Model, Stack, Store, XPath,
    splice = [].splice;

  Stack = require('stacktrace-parser');

  Emitter = require('events').EventEmitter;

  Store = require('./store');

  Container = require('./container');

  XPath = require('./xpath');

  Model = (function() {
    var enqueue;

    // ## Class Model
    class Model extends Container {
      constructor() {
        var base;
        // CS2 does not support below
        // unless this instanceof Model then return new Model arguments...
        super(...arguments);
        this.state.transactable = false;
        this.state.maxTransactions = 100;
        this.state.queue = [];
        this.state.imports = new Map();
        this.state.store = void 0;
        if (typeof (base = this.schema).on === "function") {
          base.on('change', (elem) => {
            var props;
            this.debug(`[adaptive] detected schema change at ${elem.datapath}`);
            try {
              props = this.find(elem.datapath);
            } catch (error) {
              props = [];
            }
            return props.forEach(function(prop) {
              return prop.set(prop.content, {
                force: true
              });
            });
          });
        }
        this.debug(`created a new YANG Model: ${this.name}`);
      }

      // ### attach
      attach(obj, parent, opts) {
        var ref;
        if (!(obj instanceof Object)) {
          return this;
        }
        this.store = (ref = parent != null ? parent.store : void 0) != null ? ref : new Store();
        if (!this.attached) {
          this.set(obj, opts);
        }
        this.store.add(this);
        this.state.attached = true;
        return this;
      }

      // ### access (model)

        // This is a unique capability for a Model to be able to access any
      // other arbitrary model present inside the `Model.store`.
      access(model) {
        var ref;
        return (ref = this.store) != null ? ref.access(model) : void 0;
      }

      // ### save

        // This routine triggers a 'commit' event for listeners to handle any
      // persistence operations. It also clears the `@state.queue` transaction
      // queue so that future [rollback](#rollback) will reset back to this
      // state.
      save() {
        this.debug("[save] trigger commit and clear queue");
        this.emit('commit', this.state.queue.slice());
        this.state.queue.splice(0, this.state.queue.length);
        return this;
      }

      // ### rollback

        // This routine will replay tracked `@state.queue` in reverse chronological
      // order (most recent -> oldest) when `@transactable` is set to
      // `true`. It will restore the Property instance back to the last known
      // [save](#save-opts) state.
      rollback() {
        var change;
        while (change = this.state.queue.pop()) {
          change.target.set(change.value, {
            suppress: true
          });
        }
        return this;
      }

      // ## Prototype Overrides

        // ### on (event)

        // The `Model` instance registers `@state` as an `EventEmitter` and you
      // can attach various event listeners to handle events generated by the
      // `Model`:

        // event | arguments | description
      // --- | --- | ---
      // update | (prop, prev) | fired when an update takes place within the data tree
      // change | (elems...) | fired when the schema is modified
      // create | (items...) | fired when one or more `list` element is added
      // delete | (items...) | fired when one or more `list` element is deleted

        // It also accepts optional XPATH/YPATH expressions which will *filter*
      // for granular event subscription to specified events from only the
      // elements of interest.

        // The event listeners to the `Model` can handle any customized behavior
      // such as saving to database, updating read-only state, scheduling
      // background tasks, etc.

        // This operation is protected from recursion, where operations by the
      // `callback` may result in the same `callback` being executed multiple
      // times due to subsequent events triggered due to changes to the
      // `Model`. Currently, it will allow the same `callback` to be executed
      // at most two times within the same execution stack.
      emit(event) {
        var ref;
        super.emit(...arguments);
        if (event !== 'error') {
          return (ref = this.store) != null ? ref.emit(...arguments) : void 0;
        }
      }

      on(event, ...filters) {
        var $$$, callback, ctx, recursive, ref;
        ref = filters, [...filters] = ref, [callback] = splice.call(filters, -1);
        if (!(callback instanceof Function)) {
          throw new Error("must supply callback function to listen for events");
        }
        recursive = function(name) {
          var callee, column, file, frame, frames, i, j, len, lineNumber, seen;
          seen = {};
          frames = Stack.parse(new Error().stack);
          for (i = j = 0, len = frames.length; j < len; i = ++j) {
            frame = frames[i];
            if (!(~frame.methodName.indexOf(name))) {
              continue;
            }
            ({file, lineNumber, column} = frames[i - 1]);
            callee = `${file}:${lineNumber}:${column}`;
            if (seen[callee] == null) {
              seen[callee] = 0;
            }
            if (++seen[callee] > 1) {
              console.warn(`detected recursion for '${callee}'`);
              return true;
            }
          }
          return false;
        };
        ctx = this.context;
        $$$ = function(prop, ...args) {
          if (typeof debug === "function") {
            debug(`$$$: check if '${prop.path}' in '${filters}'`);
          }
          if (!filters.length || prop.path.contains(...filters)) {
            if (!recursive('$$$')) {
              return callback.apply(ctx, [prop].concat(args));
            }
          }
        };
        return this.state.on(event, $$$);
      }

      // Please refer to [Model Events](../TUTORIAL.md#model-events) section of
      // the [Getting Started Guide](../TUTORIAL.md) for usage examples.

        // ### find (pattern)

        // This routine enables *cross-model* property search when the `Model` is
      // joined to another object (such as a datastore). The schema-bound model
      // restricts *cross-model* property access to only those modules that are
      // `import` dependencies of the current model instance.
      find(pattern = '.', opts = {}) {
        var e, match, ref, target, xpath;
        if (!this.attached) {
          return super.find(...arguments);
        }
        this.debug(`[find] match ${pattern} (root: ${opts.root})`);
        try {
          match = super.find(pattern, {
            root: true
          });
        } catch (error) {
          e = error;
          match = [];
        }
        if (match.length || opts.root) {
          return match;
        }
        xpath = (function() {
          switch (false) {
            case !(pattern instanceof XPath):
              return pattern;
            default:
              return XPath.parse(pattern, this.schema);
          }
        }).call(this);
        if (xpath.xpath == null) {
          return [];
        }
        [target] = xpath.xpath.tag.split(':');
        if (target === this.name) {
          return [];
        }
        // enforce cross-model access only to import dependencies
        if (!((ref = this.schema.import) != null ? ref.some(function(x) {
          return x.tag === target;
        }) : void 0)) {
          return [];
        }
        this.debug(`[find] locate ${target} and apply ${xpath}`);
        opts.root = true;
        try {
          return this.access(target).find(xpath, opts);
        } catch (error) {}
        try {
          // TODO: below is kind of heavy-handed...
          return this.schema.lookup('module', target).eval(this.content).find(xpath, opts);
        } catch (error) {}
        return [];
      }

    };

    Model.prototype.logger = require('debug')('yang:model');

    // ### Computed Properties
    enqueue = function(prop) {
      if (this.queue.length > this.maxTransactions) {
        throw prop.error(`exceeded max transaction queue of ${this.maxTransactions}, forgot to save()?`);
      }
      return this.queue.push({
        target: prop,
        value: prop.state.prev
      });
    };

    Model.property('transactable', {
      enumerable: true,
      get: function() {
        return this.state.transactable;
      },
      set: function(toggle) {
        if (toggle === this.state.transactable) {
          return;
        }
        if (toggle === true) {
          this.state.on('update', enqueue);
        } else {
          this.state.removeListener('update', enqueue);
          this.state.queue.splice(0, this.state.queue.length);
        }
        return this.state.transactable = toggle;
      }
    });

    Model.property('store', {
      get: function() {
        return this.state.store;
      },
      set: function(store) {
        return this.state.store = store;
      }
    });

    return Model;

  }).call(this);

  
  // ## Export Model Class
  module.exports = Model;

}).call(this);
